---
phase: 52-eliminate-native-v2-stubs
plan: 06
type: execute
wave: 3
depends_on: ["52-01", "52-02"]
files_modified:
  - src/migrate_backend_cmd.rs
  - src/graph/ast_extractor.rs
  - src/generation/mod.rs
autonomous: true

must_haves:
  truths:
    - "Migration command transfers side table data to KV during backend migration"
    - "AST nodes, CFG blocks, and chunks are copied from SQLite to KV"
    - "Migration verification step confirms all data transferred"
    - "Integration test demonstrates successful round-trip migration"
  artifacts:
    - path: "src/migrate_backend_cmd.rs"
      provides: "Side table to KV migration logic"
      contains: "migrate_side_tables_to_kv function"
      min_lines: 400
    - path: "src/graph/ast_extractor.rs"
      provides: "KV-backed AST node storage"
      contains: "store_ast_nodes_kv, get_ast_nodes_kv functions"
      min_lines: 350
  key_links:
    - from: "src/migrate_backend_cmd.rs"
      to: "src/graph/ast_extractor.rs"
      via: "AST node migration during backend conversion"
      pattern: "ast_extractor::store_ast_nodes_kv"
    - from: "src/migrate_backend_cmd.rs"
      to: "src/graph/cfg_extractor.rs"
      via: "CFG block migration during backend conversion"
      pattern: "cfg_extractor::store_cfg_blocks_kv"
    - from: "src/migrate_backend_cmd.rs"
      to: "src/generation/mod.rs"
      via: "Chunk migration during backend conversion"
      pattern: "ChunkStore::migrate_chunks_to_kv"
---

<objective>
Enhance backend migration to transfer side table data (chunks, AST nodes, CFG blocks) from SQLite to KV store.

Purpose: Ensure data preservation when migrating from SQLite to Native V2 backend, including all metadata currently stored in side tables.

Output: Migration command migrates side tables to KV, with verification step confirming data integrity.
</objective>

<execution_context>
@/home/feanor/.claude/get-shit-done/workflows/execute-plan.md
@/home/feanor/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/52-eliminate-native-v2-stubs/52-RESEARCH.md
@.planning/phases/52-eliminate-native-v2-stubs/52-01-SUMMARY.md
@.planning/phases/52-eliminate-native-v2-stubs/52-02-SUMMARY.md
@.planning/phases/52-eliminate-native-v2-stubs/52-05-SUMMARY.md

@src/migrate_backend_cmd.rs
@src/graph/ast_extractor.rs
@src/generation/mod.rs
@src/graph/cfg_extractor.rs
@src/kv/keys.rs
@src/kv/encoding.rs
@src/kv/mod.rs
@.planning/phases/47-data-migration/47-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add KV storage functions to ast_extractor module</name>
  <files>src/graph/ast_extractor.rs</files>
  <action>
Add KV-backed storage functions to src/graph/ast_extractor.rs:

1. Add store_ast_nodes_kv() function (after the existing AST extraction functions):
   ```rust
   #[cfg(feature = "native-v2")]
   pub fn store_ast_nodes_kv(
       backend: Rc<dyn sqlitegraph::GraphBackend>,
       file_id: u64,
       nodes: &[AstNode],
   ) -> Result<()> {
       use crate::kv::keys::ast_nodes_key;
       use crate::kv::encoding::encode_ast_nodes;

       let key = ast_nodes_key(file_id);
       let encoded = encode_ast_nodes(nodes)?;
       backend.kv_set(key, sqlitegraph::backend::KvValue::Bytes(encoded), None)?;
       Ok(())
   }
   ```

2. Add get_ast_nodes_kv() function:
   ```rust
   #[cfg(feature = "native-v2")]
   pub fn get_ast_nodes_kv(
       backend: &dyn sqlitegraph::GraphBackend,
       file_id: u64,
   ) -> Result<Vec<AstNode>> {
       use crate::kv::keys::ast_nodes_key;
       use crate::kv::encoding::decode_ast_nodes;

       let key = ast_nodes_key(file_id);
       let snapshot = sqlitegraph::SnapshotId::current();

       match backend.kv_get(snapshot, &key)? {
           Some(sqlitegraph::backend::KvValue::Bytes(data)) => {
               decode_ast_nodes(&data)
           }
           _ => Ok(vec![]),
       }
   }
   ```

3. Add serde derives to AstNode struct if not present:
   - Check if AstNode already has #[derive(serde::Serialize, serde::Deserialize)]
   - If not, add the derives

DO NOT:
- Modify the AST extraction logic itself (only add storage)
- Remove SQLite storage path (keep dual-mode for existing code)
- Change AstNode struct fields
  </action>
  <verify>
cargo test --package magellan --lib ast_extractor::tests::test_ast_storage_kv
  </verify>
  <done>
AST extractor has KV storage for nodes in native-v2 mode, with unit tests proving functionality.
  </done>
</task>

<task type="auto">
  <name>Add chunk migration function to ChunkStore</name>
  <files>src/generation/mod.rs</files>
  <action>
Add chunk migration helper to src/generation/mod.rs:

1. Add migrate_chunks_to_kv() static method:
   ```rust
   #[cfg(feature = "native-v2")]
   pub fn migrate_chunks_to_kv(
       sqlite_db_path: &Path,
       kv_backend: Rc<dyn sqlitegraph::GraphBackend>,
   ) -> Result<usize> {
       // Open SQLite connection
       let conn = rusqlite::Connection::open(sqlite_db_path)?;

       // Query all chunks
       let mut stmt = conn.prepare("SELECT id, file_path, byte_start, byte_end, content, content_hash, symbol_name, symbol_kind, created_at FROM code_chunks")?;

       let chunks = stmt.query_map([], |row| {
           Ok(CodeChunk {
               id: row.get(0)?,
               file_path: row.get(1)?,
               byte_start: row.get(2)?,
               byte_end: row.get(3)?,
               content: row.get(4)?,
               content_hash: row.get(5)?,
               symbol_name: row.get(6)?,
               symbol_kind: row.get(7)?,
               created_at: row.get(8)?,
           })
       })?;

       let mut count = 0;
       for chunk in chunks {
           let chunk = chunk?;
           // Store in KV using encode_json
           let key = crate::kv::keys::chunk_key(&chunk.file_path, chunk.byte_start, chunk.byte_end);
           let json = serde_json::to_vec(&chunk)?;
           kv_backend.kv_set(key, sqlitegraph::backend::KvValue::Bytes(json), None)?;
           count += 1;
       }

       Ok(count)
   }
   ```

DO NOT:
- Modify existing chunk storage/retrieval logic
- Change the CodeChunk struct
  </action>
  <verify>
cargo check --features native-v2
  </verify>
  <done>
ChunkStore has migrate_chunks_to_kv() function for transferring chunks from SQLite to KV.
  </done>
</task>

<task type="auto">
  <name>Enhance migration command with side table transfer</name>
  <files>src/migrate_backend_cmd.rs</files>
  <action>
Modify src/migrate_backend_cmd.rs to add side table to KV migration:

1. Add migrate_side_tables_to_kv() function (after migrate_side_tables(), around line 200):
   ```rust
   #[cfg(feature = "native-v2")]
   fn migrate_side_tables_to_kv(
       sqlite_db_path: &Path,
       native_backend: &Rc<dyn sqlitegraph::GraphBackend>,
   ) -> Result<MigrationSideStats> {
       use crate::generation::ChunkStore;
       use crate::graph::ast_extractor;
       use crate::graph::cfg_extractor;

       let mut stats = MigrationSideStats {
           execution_logs: 0,
           file_metrics: 0,
           symbol_metrics: 0,
           ast_nodes: 0,
           cfg_blocks: 0,
           chunks: 0,
       };

       let conn = rusqlite::Connection::open(sqlite_db_path)?;

       // 1. Migrate chunks
       stats.chunks = ChunkStore::migrate_chunks_to_kv(sqlite_db_path, Rc::clone(native_backend))?;

       // 2. Migrate AST nodes
       let mut stmt = conn.prepare("SELECT DISTINCT file_id FROM ast_nodes")?;
       let file_ids = stmt.query_map([], |row| row.get(0))?;

       for file_id_result in file_ids {
           let file_id: i64 = file_id_result?;
           let mut stmt = conn.prepare("SELECT id, parent_id, kind, byte_start, byte_end, file_id FROM ast_nodes WHERE file_id = ?")?;
           let nodes = stmt.query_map(params![file_id], |row| {
               Ok(crate::graph::ast_extractor::AstNode {
                   id: row.get(0)?,
                   parent_id: row.get(1)?,
                   kind: row.get(2)?,
                   byte_start: row.get(3)?,
                   byte_end: row.get(4)?,
                   file_id: row.get(5)?,
               })
           })?;

           let nodes_vec: Vec<_> = nodes.filter_map(|n| n.ok()).collect();
           ast_extractor::store_ast_nodes_kv(Rc::clone(native_backend), file_id as u64, &nodes_vec)?;
           stats.ast_nodes += nodes_vec.len();
       }

       // 3. Migrate CFG blocks
       let mut stmt = conn.prepare("SELECT DISTINCT function_id FROM cfg_blocks")?;
       let func_ids = stmt.query_map([], |row| row.get(0))?;

       for func_id_result in func_ids {
           let func_id: i64 = func_id_result?;
           let mut stmt = conn.prepare("SELECT id, function_id, kind, terminator, byte_start, byte_end, start_line, start_col, end_line, end_col FROM cfg_blocks WHERE function_id = ?")?;
           let blocks = stmt.query_map(params![func_id], |row| {
               Ok(crate::graph::cfg_extractor::CfgBlock {
                   id: row.get(0)?,
                   function_id: row.get(1)?,
                   kind: row.get(2)?,
                   terminator: row.get(3)?,
                   byte_start: row.get(4)?,
                   byte_end: row.get(5)?,
                   start_line: row.get(6)?,
                   start_col: row.get(7)?,
                   end_line: row.get(8)?,
                   end_col: row.get(9)?,
               })
           })?;

           let blocks_vec: Vec<_> = blocks.filter_map(|b| b.ok()).collect();
           cfg_extractor::store_cfg_blocks_kv(Rc::clone(native_backend), func_id, &blocks_vec)?;
           stats.cfg_blocks += blocks_vec.len();
       }

       // Note: execution_logs and metrics use ExecutionLog/MetricsOps with KV backend
       // These are migrated via their respective APIs during normal usage

       Ok(stats)
   }
   ```

2. Update run_migrate_backend() to call migrate_side_tables_to_kv() after snapshot import:
   - After verify_import_counts(), add side table migration step
   - Pass native backend and SQLite DB path
   - Log migration stats

3. Update MigrationSideStats to include chunks, ast_nodes, cfg_blocks fields.

DO NOT:
- Modify existing snapshot export/import logic
- Change the migrate-backend CLI flags
- Break existing migration tests
  </action>
  <verify>
cargo test --package magellan --lib backend_migration_tests::test_migration_with_side_tables
  </verify>
  <done>
Migration command transfers side table data to KV, with verification step confirming integrity.
  </done>
</task>

</tasks>

<verification>
1. cargo test --package magellan --lib backend_migration_tests passes
2. cargo check --features native-v2 completes without errors
3. Manual migration test: Create SQLite DB with side tables, run migrate-backend, verify KV has data
4. Migration logs show side table transfer stats
</verification>

<success_criteria>
- Migration command transfers chunks, AST nodes, CFG blocks to KV
- Migration verification confirms data integrity
- All existing migration tests still pass
- Zero compilation errors
</success_criteria>

<output>
After completion, create `.planning/phases/52-eliminate-native-v2-stubs/52-06-SUMMARY.md` with:
- AST extractor modified: store_ast_nodes_kv(), get_ast_nodes_kv()
- ChunkStore modified: migrate_chunks_to_kv()
- Migration command enhanced: migrate_side_tables_to_kv()
- MigrationSideStats updated with chunks, ast_nodes, cfg_blocks
- Tests added: test_migration_with_side_tables
- Test results: All pass
</output>
