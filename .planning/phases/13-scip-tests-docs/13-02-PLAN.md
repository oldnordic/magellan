---
phase: 13-scip-tests-docs
plan: 02
type: execute
wave: 2
depends_on:
  - 13-01
files_modified:
  - tests/scip_export_tests.rs
autonomous: true
must_haves:
  truths:
    - "SCIP export can be parsed by scip crate without format errors"
    - "Parsed SCIP index contains expected metadata (tool info, project root)"
    - "Parsed SCIP index contains at least one Document"
    - "SCIP documents have correct language field"
    - "SCIP occurrences have valid ranges and symbol references"
  artifacts:
    - path: "tests/scip_export_tests.rs"
      provides: "Round-trip SCIP export tests"
      min_lines: 200
      contains: "scip::types::Index::parse_from_bytes"
  key_links:
    - from: "tests/scip_export_tests.rs"
      to: "magellan::export_scip"
      via: "calls export_scip to get SCIP bytes"
      pattern: "export_scip"
    - from: "tests/scip_export_tests.rs"
      to: "scip::types::Index::parse_from_bytes"
      via: "verifies SCIP bytes are parseable"
      pattern: "parse_from_bytes"
---

<objective>
Add round-trip integration tests that verify SCIP export format correctness.

Purpose: Round-trip testing (export -> parse -> verify) is the standard pattern for validating protobuf output. These tests ensure the SCIP export is compatible with the scip crate and produces valid indexes that can be consumed by SCIP tools.

Output: Integration test file with multiple tests covering metadata, documents, occurrences, and round-trip correctness.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/13-scip-tests-docs/13-RESEARCH.md
@.planning/phases/13-scip-tests-docs/13-01-SUMMARY.md
@tests/cli_export_tests.rs
@src/graph/export/scip.rs
</context>

<tasks>

<task type="auto">
  <name>Create SCIP round-trip test file structure</name>
  <files>tests/scip_export_tests.rs</files>
  <action>
    Create tests/scip_export_tests.rs with the following structure:

    ```rust
    //! SCIP export round-trip tests
    //!
    //! Verifies SCIP export format correctness by exporting then parsing.

    #![allow(clippy::needless_return)] // Allow explicit return for test clarity

    use std::fs;
    use tempfile::TempDir;
    use scip::types::Index;
    use protobuf::Message;

    fn create_test_graph_with_symbols(temp_dir: &TempDir) -> (tempfile::TempPath, String) {
        // Helper to create a test graph with known symbols
        // Returns (db_path, file_path)
    }

    #[test]
    fn test_scip_roundtrip_basic() {
        // Test: export then parse, verify structure
    }

    #[test]
    fn test_scip_parseable_by_scip_crate() {
        // Test: verify scip crate can parse output
    }

    #[test]
    fn test_scip_metadata_correct() {
        // Test: verify tool info, project root, version
    }

    #[test]
    fn test_scip_document_structure() {
        // Test: verify documents have language, relative_path
    }

    #[test]
    fn test_scip_occurrence_ranges() {
        // Test: verify occurrence ranges are valid
    }

    #[test]
    fn test_scip_symbol_encoding() {
        // Test: verify symbols follow SCIP format
    }
    ```

    Follow the pattern from tests/cli_export_tests.rs for tempfile usage and graph creation.
  </action>
  <verify>cargo test --test scip_export_tests --no-run</verify>
  <done>Test file compiles with all test functions scaffolded</done>
</task>

<task type="auto">
  <name>Implement basic round-trip test</name>
  <files>tests/scip_export_tests.rs</files>
  <action>
    Implement test_scip_roundtrip_basic:

    1. Create temp directory and test file with Rust code:
       ```rust
       fn main() {
           println!("Hello");
       }

       fn helper() -> i32 {
           42
       }
       ```

    2. Index the file using CodeGraph::open() and index_file()

    3. Export to SCIP using export_scip(graph, &ScipExportConfig::default())

    4. Parse SCIP bytes: Index::parse_from_bytes(&scip_bytes)

    5. Verify:
       - parse_from_bytes returns Ok (no decode error)
       - parsed_index.has_metadata() is true
       - parsed_index.documents() is not empty

    Use unwrap_or_else for descriptive error messages.
  </action>
  <verify>cargo test test_scip_roundtrip_basic</verify>
  <done>Test passes: SCIP export can be parsed by scip crate</done>
</task>

<task type="auto">
  <name>Implement metadata verification test</name>
  <files>tests/scip_export_tests.rs</files>
  <action>
    Implement test_scip_metadata_correct:

    1. Create a graph and export to SCIP

    2. Parse the SCIP bytes

    3. Verify metadata fields:
       - metadata.tool_info().name() == "magellan"
       - metadata.tool_info().version() is not empty
       - metadata.project_root() is set (from config)
       - metadata.has_tool_info() is true

    Test both default config and custom config:
    - ScipExportConfig::default() (project_root = ".")
    - ScipExportConfig { project_root: "/test".to_string(), ... }

    Verify the metadata reflects the config values.
  </action>
  <verify>cargo test test_scip_metadata_correct</verify>
  <done>Test passes: Metadata contains tool info and project root</done>
</task>

<task type="auto">
  <name>Implement document and occurrence tests</name>
  <files>tests/scip_export_tests.rs</files>
  <action>
    Implement test_scip_document_structure and test_scip_occurrence_ranges:

    test_scip_document_structure:
    1. Create graph with indexed file
    2. Export and parse SCIP
    3. Find the document by relative_path
    4. Verify:
       - document.language() == "rust" (or correct language)
       - document.relative_path() ends with test file name
       - document.occurrences() is not empty

    test_scip_occurrence_ranges:
    1. Create file with known symbol locations
    2. Export and parse SCIP
    3. For each occurrence in document:
       - Verify range has 3 or 4 elements [start_line, start_col, end_line, end_col]
       - Verify line numbers are non-negative
       - Verify symbol string is not empty
       - Verify symbol_roles > 0 (has at least one role)

    Handle both 3-element ranges (single line) and 4-element ranges (multi-line).
  </action>
  <verify>cargo test test_scip_document_structure test_scip_occurrence_ranges</verify>
  <done>Tests pass: Documents and occurrences have valid structure</done>
</task>

<task type="auto">
  <name>Implement symbol encoding test</name>
  <files>tests/scip_export_tests.rs</files>
  <action>
    Implement test_scip_symbol_encoding:

    1. Create a file with hierarchical symbols:
       ```rust
       mod outer {
           mod inner {
               fn function() {}
           }
       }
       ```

    2. Export and parse SCIP

    3. Verify symbol format:
       - Symbols end with "." (global symbol marker)
       - Symbols contain "magellan" scheme
       - Symbols use "/" descriptor separator
       - FQN components are present (outer, inner, function)

    4. Test for different languages (optional, add if time permits):
       - Python: module.Class.method
       - Java: package.Class.method

    Assert on symbol string format using:
    - .ends_with('.')
    - .starts_with("magellan ")
    - .contains('/') for descriptors
  </action>
  <verify>cargo test test_scip_symbol_encoding</verify>
  <done>Test passes: Symbols follow SCIP format specification</done>
</task>

</tasks>

<verification>
1. cargo test --test scip_export_tests passes all tests
2. Each test verifies a specific aspect of SCIP format correctness
3. Tests use real CodeGraph instances (no mocking)
4. Round-trip pattern: export -> parse -> assert
</verification>

<success_criteria>
- All SCIP round-trip tests pass
- SCIP export produces parseable protobuf output
- Metadata, documents, and occurrences are verified
- Symbol encoding follows SCIP format
</success_criteria>

<output>
After completion, create `.planning/phases/13-scip-tests-docs/13-02-SUMMARY.md`
</output>
