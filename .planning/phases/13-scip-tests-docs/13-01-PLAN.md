---
phase: 13-scip-tests-docs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/export/scip.rs
  - Cargo.toml
autonomous: true
must_haves:
  truths:
    - "SCIP export produces valid protobuf bytes parseable by scip crate"
    - "SCIP index contains metadata (tool info, project root, protocol version)"
    - "SCIP documents include language and position_encoding fields"
    - "SCIP occurrences contain symbol references and range information"
    - "SCIP export returns non-empty Vec<u8> for non-empty graphs"
  artifacts:
    - path: "src/graph/export/scip.rs"
      provides: "SCIP export implementation using scip crate"
      min_lines: 150
      contains: "scip::types::Index", "scip::types::Document", "scip::types::Occurrence"
    - path: "Cargo.toml"
      provides: "scip and protobuf dependency declarations"
      contains: "scip =", "protobuf ="
  key_links:
    - from: "src/graph/export/scip.rs"
      to: "scip::types::Index"
      via: "use scip::types::{Index, Metadata, Document, Occurrence}"
      pattern: "use scip::types"
    - from: "src/graph/export/scip.rs"
      to: "protobuf::Message"
      via: "use protobuf::Message for write_to_bytes()"
      pattern: "write_to_bytes"
    - from: "export_scip"
      to: "CodeGraph"
      via: "reads symbols, references, calls from graph"
      pattern: "graph\\.symbols|graph\\.all_symbols"
---

<objective>
Implement SCIP export using the scip crate to produce valid protobuf output.

Purpose: SCIP (Source Code Intelligence Protocol) is a standardized format for code indexing used by Sourcegraph and other tools. This plan replaces the stub implementation with a working export using the official scip crate bindings.

Output: SCIP index containing metadata, documents with occurrences (definitions and references), and valid protobuf serialization.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/13-scip-tests-docs/13-RESEARCH.md
@src/graph/export/scip.rs
@src/graph/mod.rs
@src/graph/schema.rs
</context>

<tasks>

<task type="auto">
  <name>Implement SCIP Index construction with metadata</name>
  <files>src/graph/export/scip.rs</files>
  <action>
    Replace the stub export_scip function with a real implementation:

    1. Add imports:
       ```rust
       use scip::types::{Index, Metadata, Document, Occurrence, SymbolInformation, ToolInfo, PositionEncoding};
       use protobuf::Message;
       ```

    2. Create ScipExportConfig implementation (already exists, keep it)

    3. In export_scip, build the Index:
       - Create Index::new()
       - Build Metadata with:
         - ToolInfo containing "magellan" and env!("CARGO_PKG_VERSION")
         - project_root from config.project_root
       - Set metadata on index with index.set_metadata()

    4. For each file in graph.files():
       - Create Document with relative_path, language
       - Set position_encoding to Utf8CodeUnitOffsetFromLineStart
       - For each symbol in the file:
         - Create Occurrence with range [line_start, col_start, line_end, col_end]
         - Set symbol using SCIP symbol format (use fqn if available, fallback to name)
         - Set symbol_roles (Definition for definitions, Reference for references)
         - Add to document.occurrences
       - Add document to index.documents

    5. Serialize with index.write_to_bytes() and return

    Use scip::symbol::format_symbol() for proper SCIP symbol encoding if available.

    DO NOT: Create custom protobuf types, use manual byte encoding
  </action>
  <verify>cargo check --all-targets</verify>
  <done>export_scip returns non-empty Vec<u8> containing valid SCIP protobuf</done>
</task>

<task type="auto">
  <name>Map Magellan symbols to SCIP occurrences</name>
  <files>src/graph/export/scip.rs</files>
  <action>
    Extend the export_scip implementation to map Magellan's graph data to SCIP occurrences:

    1. For symbols (definitions):
       - Create Occurrence with symbol_roles = Definition (1)
       - Range from symbol's byte_start/byte_end converted to line/col
       - Symbol encoded as "rust magellan/namespace/symbol/." format

    2. For references:
       - Create Occurrence with symbol_roles = Reference (5 or more)
       - Use reference's location for range
       - Symbol should reference the target symbol's SCIP symbol

    3. Language mapping for SCIP:
       - Rust -> "rust"
       - Python -> "python"
       - JavaScript -> "javascript"
       - TypeScript -> "typescript"
       - Java -> "java"
       - C -> "c"
       - C++ -> "cpp"

    Convert byte offsets to line/column using the source text if available,
    or approximate using average line length if source text not stored.

    Store occurrences per-document in index.documents.
  </action>
  <verify>cargo test --lib export</verify>
  <done>SCIP index contains at least one Document with Occurrences for test fixtures</done>
</task>

<task type="auto">
  <name>Add SCIP symbol encoding helper</name>
  <files>src/graph/export/scip.rs</files>
  <action>
    Create a helper function to convert Magellan FQNs to SCIP symbol format:

    ```rust
    fn magellan_symbol_to_scip(fqn: &str, language: &str) -> String {
        // SCIP symbol format: scheme package/descriptor1/descriptor2.
        // For Magellan, use "magellan" as scheme and language as package

        let parts: Vec<&str> = match language {
            "rust" => fqn.split("::").collect(),
            "python" | "java" | "javascript" | "typescript" => fqn.split('.').collect(),
            "cpp" => fqn.split("::").collect(),
            _ => vec![fqn],
        };

        // Build SCIP symbol string
        // Format: magellan lang/descriptor1/descriptor2/symbol.
        let symbol = parts.last().unwrap_or(&"");
        let descriptors: Vec<String> = parts.iter()
            .take(parts.len().saturating_sub(1))
            .map(|s| s.to_string())
            .collect();

        format!("magellan {language}/{}{}/.",
            descriptors.join("/"),
            symbol)
    }
    ```

    Use scip::symbol::format_symbol() if available for proper escaping.
    Otherwise use string formatting with proper escaping for spaces/special chars.
  </action>
  <verify>cargo check --lib</verify>
  <done>magellan_symbol_to_scip converts "crate::module::function" to "magellan rust/crate/module/function."</done>
</task>

</tasks>

<verification>
1. cargo check passes without errors
2. cargo test --lib shows new symbols available
3. export_scip returns non-empty Vec<u8> for graphs with symbols
</verification>

<success_criteria>
- SCIP export produces parseable protobuf output
- Index contains required metadata fields
- At least one document with occurrences is generated
- Symbol encoding follows SCIP format requirements
</success_criteria>

<output>
After completion, create `.planning/phases/13-scip-tests-docs/13-01-SUMMARY.md`
</output>
