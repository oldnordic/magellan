---
phase: 06-query-ux
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/output/command.rs
  - src/graph/references.rs
  - src/refs_cmd.rs
autonomous: true

must_haves:
  truths:
    - "User can look up references to a symbol and receive target symbol's stable ID"
    - "ReferenceMatch includes target_symbol_id in JSON output"
    - "Reference query returns both referenced_symbol name and its stable ID"
  artifacts:
    - path: "src/output/command.rs"
      provides: "ReferenceMatch with target_symbol_id field"
      contains: "struct ReferenceMatch"
    - path: "src/graph/references.rs"
      provides: "Reference query returning target IDs"
    - path: "src/refs_cmd.rs"
      provides: "Refs command with target ID in output"
  key_links:
    - from: "src/refs_cmd.rs:output_json_mode"
      to: "ReferenceMatch"
      via: "Pass target_symbol_id to ReferenceMatch::new"
    - from: "src/graph/references.rs:references_to_symbol"
      to: "SymbolNode"
      via: "Fetch symbol_id from referenced Symbol node"
---

<objective>
Add target_symbol_id to references so users can correlate references to their stable symbol identifiers.

Purpose: ReferenceMatch currently only includes referenced_symbol (name). Adding target_symbol_id enables stable correlation across runs. When a user queries references to "main", they get the stable ID of that symbol for downstream tooling.

Output: ReferenceMatch with optional target_symbol_id field, populated from graph.

Context: Research identified gap in src/refs_cmd.rs. References don't include the stable ID of the referenced symbol. SymbolNode already has symbol_id field. Need to fetch it during reference query and propagate to output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-query-ux/06-RESEARCH.md
@src/refs_cmd.rs
@src/graph/references.rs
@src/output/command.rs
@src/graph/schema.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add target_symbol_id field to ReferenceMatch</name>
  <files>src/output/command.rs</files>
  <action>
    In src/output/command.rs, add a new field to ReferenceMatch struct (around line 570):

    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ReferenceMatch {
        pub match_id: String,
        pub span: Span,
        pub referenced_symbol: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        pub reference_kind: Option<String>,
        /// Stable symbol ID of the referenced symbol
        #[serde(skip_serializing_if = "Option::is_none")]
        pub target_symbol_id: Option<String>,
    }
    ```

    Update ReferenceMatch::new() signature (around line 658) to accept target_symbol_id:

    ```rust
    pub fn new(
        span: Span,
        referenced_symbol: String,
        reference_kind: Option<String>,
        target_symbol_id: Option<String>,
    ) -> Self {
        let match_id = Self::generate_match_id(&referenced_symbol, &span.file_path, span.byte_start);
        ReferenceMatch {
            match_id,
            span,
            referenced_symbol,
            reference_kind,
            target_symbol_id,
        }
    }
    ```

    Use skip_serializing_if for backward compatibility with existing JSON consumers.
  </action>
  <verify>
    cargo check
    cargo test --package magellan reference
  </verify>
  <done>
    ReferenceMatch struct includes target_symbol_id field with proper serialization.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fetch target_symbol_id in references query</name>
  <files>src/graph/references.rs</files>
  <action>
    Modify ReferenceOps::references_to_symbol() to return target symbol IDs.

    Current implementation (line 197-214) returns Vec<ReferenceFact> with only name.

    New approach:
    1. After getting Reference node from reference_fact_from_node(), get the target Symbol node
    2. Follow the REFERENCES edge from Reference node to Symbol node
    3. Extract symbol_id from SymbolNode.data
    4. Return (ReferenceFact, Option<String>) tuples

    Change signature to:
    ```rust
    pub fn references_to_symbol(&mut self, symbol_id: i64) -> Result<Vec<(ReferenceFact, Option<String>)>>
    ```

    For each reference_node_id:
    1. Get the Reference node (existing code)
    2. Get outgoing REFERENCES edge neighbors from the reference node
    3. For each target symbol node, deserialize as SymbolNode and extract symbol_id
    4. Return (reference_fact, symbol_id) tuple

    Keep existing reference_fact_from_node() as-is.
  </action>
  <verify>
    cargo check
    cargo test --package magellan reference
  </verify>
  <done>
    Reference query returns both span and target symbol ID.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update refs_cmd.rs to populate target_symbol_id</name>
  <files>src/refs_cmd.rs</files>
  <action>
    Update refs_cmd.rs to use the new return type from references_to_symbol().

    In run_refs(), the calls variable is now Vec<(ReferenceFact, Option<String>)>.

    Update output_json_mode() (around line 155):
    1. Accept Vec<(CallFact, ...)> or change to work with new type
    2. For CallFact conversion to ReferenceMatch, also fetch target_symbol_id

    Actually, CallFact is used for calls, not references. The refs command uses CallFact from call graph, not ReferenceFact.

    For QRY-02, we need to handle actual references, not calls. But the current refs command uses CallFact from call graph.

    Given the current architecture, the refs command shows calls (caller/callee), not general references. For this plan:

    1. Add target_symbol_id to CallFact (or use existing CallFact.callee name to lookup symbol_id)
    2. In output_json_mode(), look up the symbol_id for the referenced symbol
    3. Pass it to ReferenceMatch::new()

    Implementation:
    - In output_json_mode(), for each CallFact, look up symbol_id from graph
    - Use symbol_nodes_in_file_with_ids() to find the symbol by name in the call's file
    - Pass the symbol_id to ReferenceMatch::new()

    This is a pragmatic approach that doesn't require changing CallFact schema.
  </action>
  <verify>
    cargo check
    cargo test refs
  </verify>
  <done>
    refs command JSON output includes target_symbol_id for referenced symbols.
  </done>
</task>

<task type="auto">
  <name>Task 4: Add test for target_symbol_id in refs output</name>
  <files>tests/cli_query_tests.rs</files>
  <action>
    Add test verifying target_symbol_id appears in refs JSON output.

    Test pattern:
    1. Create test file with caller/callee functions
    2. Index the file and calls
    3. Run refs --name callee --direction in --output json
    4. Parse JSON and verify references[0].target_symbol_id exists

    Place after existing refs tests (around line 830).

    Test name: test_refs_includes_target_symbol_id_in_json
  </action>
  <verify>
    cargo test test_refs_includes_target_symbol_id_in_json
  </verify>
  <done>
    Test confirms target_symbol_id is present in refs JSON output.
  </done>
</task>

</tasks>

<verification>
1. cargo check passes
2. cargo test refs passes
3. Manual: magellan refs --db test.db --name main --path test.rs --direction in --output json | jq '.data.references[0].target_symbol_id'
4. JSON includes target_symbol_id for all references
</verification>

<success_criteria>
1. ReferenceMatch struct has target_symbol_id field
2. refs command JSON output includes target_symbol_id
3. target_symbol_id is None for symbols without stable IDs (backward compat)
4. Existing tests pass
5. New test validates target_symbol_id presence
</success_criteria>

<output>
After completion, create `.planning/phases/06-query-ux/06-02-SUMMARY.md`
</output>
