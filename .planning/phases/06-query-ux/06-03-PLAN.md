---
phase: 06-query-ux
plan: 03
type: execute
wave: 2
depends_on: [06-02]
files_modified:
  - src/references.rs
  - src/graph/schema.rs
  - src/graph/call_ops.rs
  - src/refs_cmd.rs
autonomous: true

must_haves:
  truths:
    - "User can query callers/callees and receive stable IDs for both caller and callee"
    - "Call results are deterministically ordered (file_path, byte_start)"
    - "JSON output includes caller_symbol_id and callee_symbol_id"
  artifacts:
    - path: "src/references.rs"
      provides: "CallFact with optional symbol_id fields"
      contains: "pub struct CallFact"
    - path: "src/graph/schema.rs"
      provides: "CallNode with optional symbol_id fields"
      contains: "pub struct CallNode"
    - path: "src/graph/call_ops.rs"
      provides: "Call indexing with symbol_id storage"
    - path: "src/refs_cmd.rs"
      provides: "Refs output with call graph IDs"
  key_links:
    - from: "src/graph/call_ops.rs:index_calls"
      to: "CallNode"
      via: "Store caller_symbol_id and callee_symbol_id"
    - from: "src/refs_cmd.rs:output_json_mode"
      to: "ReferenceMatch or new CallMatch type"
      via: "Include caller/callee symbol IDs in output"
---

<objective>
Add symbol_id to call graph results so users get stable identifiers for both caller and callee.

Purpose: CallFact currently only has caller and callee names. Adding caller_symbol_id and callee_symbol_id enables stable correlation. When querying "who calls main", users get both the caller name and its stable ID.

Output: CallFact with optional caller_symbol_id and callee_symbol_id fields, populated during indexing and returned in queries.

Context: CallNode schema (src/graph/schema.rs) and CallFact (src/references.rs) need extension. Call indexing (src/graph/call_ops.rs) needs to fetch and store symbol IDs. Refs command needs to include IDs in JSON output. This is more complex than 06-02 because it changes indexing, not just query.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/06-query-ux/06-RESEARCH.md
@src/graph/call_ops.rs
@src/graph/schema.rs
@src/references.rs
@src/refs_cmd.rs
@src/graph/query.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend CallNode schema with symbol_id fields</name>
  <files>src/graph/schema.rs</files>
  <action>
    In src/graph/schema.rs, add optional symbol_id fields to CallNode (around line 54):

    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct CallNode {
        pub file: String,
        pub caller: String,
        pub callee: String,
        /// Stable symbol ID of the caller
        #[serde(default)]
        pub caller_symbol_id: Option<String>,
        /// Stable symbol ID of the callee
        #[serde(default)]
        pub callee_symbol_id: Option<String>,
        pub byte_start: u64,
        pub byte_end: u64,
        pub start_line: u64,
        pub start_col: u64,
        pub end_line: u64,
        pub end_col: u64,
    }
    ```

    Use #[serde(default)] for backward compatibility with existing Call nodes in databases.
  </action>
  <verify>
    cargo check
  </verify>
  <done>
    CallNode schema includes caller_symbol_id and callee_symbol_id fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend CallFact with symbol_id fields</name>
  <files>src/references.rs</files>
  <action>
    In src/references.rs, add optional symbol_id fields to CallFact (around line 37):

    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
    pub struct CallFact {
        pub file_path: PathBuf,
        pub caller: String,
        pub callee: String,
        /// Stable symbol ID of the caller
        #[serde(default)]
        pub caller_symbol_id: Option<String>,
        /// Stable symbol ID of the callee
        #[serde(default)]
        pub callee_symbol_id: Option<String>,
        pub byte_start: usize,
        pub byte_end: usize,
        pub start_line: usize,
        pub start_col: usize,
        pub end_line: usize,
        pub end_col: usize,
    }
    ```

    Update extract_calls() in CallExtractor to populate these fields by looking up symbol_ids from the symbol_map.
  </action>
  <verify>
    cargo check
  </verify>
  <done>
    CallFact includes caller_symbol_id and callee_symbol_id fields.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update call indexing to store symbol_ids</name>
  <files>src/graph/call_ops.rs</files>
  <action>
    In src/graph/call_ops.rs, update insert_call_node() (around line 217) to include symbol_ids:

    ```rust
    fn insert_call_node(&self, call: &CallFact) -> Result<NodeId> {
        let call_node = CallNode {
            file: call.file_path.to_string_lossy().to_string(),
            caller: call.caller.clone(),
            callee: call.callee.clone(),
            caller_symbol_id: call.caller_symbol_id.clone(),
            callee_symbol_id: call.callee_symbol_id.clone(),
            byte_start: call.byte_start as u64,
            byte_end: call.byte_end as u64,
            start_line: call.start_line as u64,
            start_col: call.start_col as u64,
            end_line: call.end_line as u64,
            end_col: call.end_col as u64,
        };
        // ... rest of function
    }
    ```

    Update index_calls() to pass symbol_ids when creating CallFact.
    The symbol_ids HashMap already maps name -> node_id. Need to also lookup the SymbolNode to get symbol_id.

    Add helper to get symbol_id by name from graph.
  </action>
  <verify>
    cargo check
    cargo test call
  </verify>
  <done>
    Call indexing stores caller_symbol_id and callee_symbol_id in Call nodes.
  </done>
</task>

<task type="auto">
  <name>Task 4: Update call_fact_from_node to deserialize symbol_ids</name>
  <files>src/graph/call_ops.rs</files>
  <action>
    In src/graph/call_ops.rs, update call_fact_from_node() (around line 268) to include symbol_ids:

    ```rust
    fn call_fact_from_node(&self, node_id: i64) -> Result<Option<CallFact>> {
        let node = self.backend.get_node(node_id)?;
        let call_node: Option<CallNode> = serde_json::from_value(node.data).ok()?;

        let call_node = match call_node {
            Some(n) => n,
            None => return Ok(None),
        };

        Ok(Some(CallFact {
            file_path: PathBuf::from(&call_node.file),
            caller: call_node.caller,
            callee: call_node.callee,
            caller_symbol_id: call_node.caller_symbol_id,
            callee_symbol_id: call_node.callee_symbol_id,
            byte_start: call_node.byte_start as usize,
            byte_end: call_node.byte_end as usize,
            start_line: call_node.start_line as usize,
            start_col: call_node.start_col as usize,
            end_line: call_node.end_line as usize,
            end_col: call_node.end_col as usize,
        }))
    }
    ```
  </action>
  <verify>
    cargo check
  </verify>
  <done>
    Call query returns CallFact with populated symbol_id fields.
  </done>
</task>

<task type="auto">
  <name>Task 5: Update refs command to include symbol_ids in JSON output</name>
  <files>src/refs_cmd.rs</files>
  <action>
    In src/refs_cmd.rs, update output_json_mode() to include symbol_ids.

    Since CallFact now has caller_symbol_id and callee_symbol_id, include these in the output.

    For direction "in" (callers), include caller_symbol_id.
    For direction "out" (callees), include callee_symbol_id.

    Use a new response type or extend ReferenceMatch. Actually, since we're dealing with calls (not general references), we may want a dedicated CallMatch type or include the IDs in the existing output.

    Pragmatic approach: Add a new field to ReferenceMatch or create a note in the JSON. For consistency with 06-02, add target_symbol_id which points to the caller or callee depending on direction.

    Implementation:
    - For "in" direction: target_symbol_id = call.caller_symbol_id
    - For "out" direction: target_symbol_id = call.callee_symbol_id

    Update ReferenceMatch::new() call to pass the symbol_id.
  </action>
  <verify>
    cargo check
    cargo test refs
  </verify>
  <done>
    refs command JSON output includes symbol_id for caller/callee.
  </done>
</task>

<task type="auto">
  <name>Task 6: Add tests for call graph symbol_id propagation</name>
  <files>tests/cli_query_tests.rs</files>
  <action>
    Add two tests:

    1. test_refs_callers_includes_symbol_id - Verify incoming calls include caller_symbol_id
    2. test_refs_callees_includes_symbol_id - Verify outgoing calls include callee_symbol_id

    Follow existing test pattern. Place after existing refs tests (after line 880).

    Both tests should:
    1. Create file with function calls
    2. Index file and calls
    3. Run refs with --output json
    4. Verify symbol_id is present in output
  </action>
  <verify>
    cargo test test_refs_callers_includes_symbol_id
    cargo test test_refs_callees_includes_symbol_id
  </verify>
  <done>
    Tests confirm call graph includes symbol IDs for both directions.
  </done>
</task>

</tasks>

<verification>
1. cargo check passes
2. cargo test refs passes
3. Manual: magellan refs --db test.db --name main --path test.rs --direction in --output json | jq '.data.references[0].target_symbol_id'
4. Manual: magellan refs --db test.db --name main --path test.rs --direction out --output json | jq '.data.references[0].target_symbol_id'
5. Re-indexing a file populates new Call nodes with symbol_ids
6. Old Call nodes (without symbol_ids) still deserialize correctly (serde default)
</verification>

<success_criteria>
1. CallNode and CallFact have caller_symbol_id and callee_symbol_id fields
2. Call indexing populates these fields from Symbol nodes
3. Call queries return symbol IDs in JSON output
4. Backward compatibility maintained (old databases work)
5. Existing tests pass
6. New tests validate symbol ID presence
</success_criteria>

<output>
After completion, create `.planning/phases/06-query-ux/06-03-SUMMARY.md`
</output>
