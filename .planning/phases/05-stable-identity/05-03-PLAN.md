---
phase: 05-stable-identity
plan: 03
type: execute
wave: 2
depends_on: [05-01]
files_modified: [src/output/command.rs, src/graph/query.rs]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "SymbolMatch includes symbol_id field"
    - "JSON output shows symbol_id for symbol results"
    - "symbol_id propagates from SymbolNode to SymbolMatch"
    - "No breaking changes - symbol_id is Option<String> with skip_serializing_if"
  artifacts:
    - path: "src/output/command.rs"
      provides: "SymbolMatch with symbol_id field"
      contains: "symbol_id: Option<String>"
    - path: "src/graph/query.rs"
      provides: "symbol_id propagation in query conversion"
      exports: ["symbols_in_file", "symbol_nodes_in_file"]
  key_links:
    - from: "src/graph/query.rs"
      to: "src/output/command.rs"
      via: "SymbolMatch::new() call with symbol_id"
      pattern: "SymbolMatch::new"
    - from: "src/output/command.rs"
      to: "src/graph/schema.rs"
      via: "SymbolNode.symbol_id field read"
      pattern: "symbol_id"

---

<objective>
Add symbol_id to JSON output types and query responses

Purpose: Enable JSON API consumers to receive stable symbol identifiers for correlation across runs, satisfying OUT-05 requirement.
Output: SymbolMatch with symbol_id field, query functions propagate symbol_id
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-stable-identity/05-RESEARCH.md

@.planning/phases/05-stable-identity/05-01-SUMMARY.md

@src/output/command.rs
@src/graph/query.rs
@src/graph/schema.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add symbol_id field to SymbolMatch struct</name>
  <files>src/output/command.rs</files>
  <action>
    Add symbol_id field to SymbolMatch in src/output/command.rs:
    1. Add field after match_id, before span:
       ```rust
       /// Stable symbol ID
       ///
       /// Generated from language, fully-qualified name, and defining span.
       /// Corresponds to the symbol's stable identifier across runs.
       #[serde(skip_serializing_if = "Option::is_none")]
       pub symbol_id: Option<String>,
       ```
    2. Update SymbolMatch::new() to accept symbol_id parameter:
       - Change signature: pub fn new(name: String, kind: String, span: Span, parent: Option<String>, symbol_id: Option<String>)
       - Add symbol_id to struct construction
    3. Update docstring example to show symbol_id field
  </action>
  <verify>cargo check succeeds (compile failures expected in callers - fixed in next task)</verify>
  <done>SymbolMatch has symbol_id: Option<String> field with serde skip_serializing_if</done>
</task>

<task type="auto">
  <name>Task 2: Update SymbolMatch::new signature and update docstring</name>
  <files>src/output/command.rs</files>
  <action>
    Complete SymbolMatch::new() updates from Task 1:
    1. Full signature with symbol_id parameter
    2. Update struct docstring example to include symbol_id
    3. Add note about symbol_id stability properties

    Example in docstring:
    ```rust
    let span = Span::new("main.rs".into(), 3, 7, 1, 3, 1, 7);
    let symbol = SymbolMatch::new(
        "main".into(),
        "Function".into(),
        span,
        None,
        Some("a1b2c3d4e5f6g7h8".into()),  // symbol_id
    );
    ```
  </action>
  <verify>cargo check reports specific call sites needing updates (query_cmd, find_cmd, etc.)</verify>
  <done>SymbolMatch::new signature complete with symbol_id parameter</done>
</task>

<task type="auto">
  <name>Task 3: Update query functions to extract and propagate symbol_id</name>
  <files>src/graph/query.rs</files>
  <action>
    Read src/graph/query.rs and update functions that create SymbolMatch:

    For each function that converts SymbolNode/SymbolFact to SymbolMatch:
    1. Extract symbol_id from SymbolNode data field
    2. Pass symbol_id to SymbolMatch::new() as 5th parameter

    Pattern to follow:
    ```rust
    let symbol_node: SymbolNode = serde_json::from_value(node.data)?;
    let symbol_id = symbol_node.symbol_id;

    // In SymbolMatch::new() call:
    SymbolMatch::new(
        name,
        kind,
        span,
        parent,
        symbol_id,  // NEW: add this parameter
    )
    ```

    Check all functions: symbols_in_file, symbols_in_file_with_kind, symbol_nodes_in_file
  </action>
  <verify>cargo check succeeds for graph module</verify>
  <done>All query functions extract and pass symbol_id to SymbolMatch::new</done>
</task>

<task type="auto">
  <name>Task 4: Update command handlers to pass symbol_id parameter</name>
  <files>src/query_cmd.rs, src/find_cmd.rs</files>
  <action>
    Read query_cmd.rs and find_cmd.rs, update SymbolMatch::new() calls:

    For each SymbolMatch::new() call:
    - Add None or actual symbol_id as 5th parameter

    Pattern:
    ```rust
    // OLD:
    SymbolMatch::new(name, kind, span, parent)

    // NEW:
    SymbolMatch::new(name, kind, span, parent, symbol_id_from_node)
    ```

    Check query_cmd.rs and find_cmd.rs for all SymbolMatch construction sites.
  </action>
  <verify>cargo check succeeds for main binary</verify>
  <done>All command handlers pass symbol_id to SymbolMatch::new</done>
</task>

<task type="auto">
  <name>Task 5: Add symbol_id to SymbolMatch tests</name>
  <files>src/output/command.rs</files>
  <action>
    Add test for SymbolMatch with symbol_id:
    - test_symbol_match_with_symbol_id(): verify serialization includes symbol_id
    - test_symbol_match_without_symbol_id(): verify skip_serializing_if works
    - test_symbol_match_symbol_id_stability(): same inputs produce same symbol_id

    Add to #[cfg(test)] module in src/output/command.rs
  </action>
  <verify>cargo test --lib output::command::tests passes</verify>
  <done>All SymbolMatch symbol_id tests pass</done>
</task>

</tasks>

<verification>
1. cargo check passes without errors
2. cargo test --lib output::command::tests includes symbol_id tests
3. SymbolMatch includes symbol_id field
4. JSON output shows symbol_id when present
5. All callers updated to new SymbolMatch::new signature
</verification>

<success_criteria>
1. SymbolMatch has symbol_id field with proper serde attributes
2. Query functions extract symbol_id from SymbolNode data
3. Command handlers pass symbol_id to SymbolMatch::new
4. JSON output includes symbol_id for symbols with stable IDs
5. No breaking changes - symbol_id is optional
6. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-stable-identity/05-03-SUMMARY.md`
</output>
