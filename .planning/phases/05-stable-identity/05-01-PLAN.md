---
phase: 05-stable-identity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/graph/schema.rs, src/graph/symbols.rs, src/ingest/mod.rs]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "symbol_id field exists on SymbolNode struct"
    - "symbol_id is generated during symbol insertion using SHA-256"
    - "symbol_id values are deterministic for same (language, fqn, span_id)"
    - "Fully-qualified name (fqn) is tracked in SymbolFact"
  artifacts:
    - path: "src/graph/schema.rs"
      provides: "SymbolNode with symbol_id field"
      contains: "symbol_id: Option<String>"
    - path: "src/ingest/mod.rs"
      provides: "SymbolFact with fqn field"
      contains: "fqn: Option<String>"
    - path: "src/graph/symbols.rs"
      provides: "symbol_id generation in insert_symbol_node"
      exports: ["insert_symbol_node"]
  key_links:
    - from: "src/graph/symbols.rs"
      to: "src/ingest/mod.rs"
      via: "fact.fqn"
      pattern: "fact\\.fqn"
    - from: "src/graph/symbols.rs"
      to: "src/graph/schema.rs"
      via: "SymbolNode { symbol_id: ... }"
      pattern: "symbol_id:"
---

<objective>
Add stable symbol_id generation to SymbolNode and SymbolFact

Purpose: Enable users to correlate symbols across runs using stable IDs derived from (language, fully-qualified name, defining span).
Output: SymbolNode schema with symbol_id field, SymbolFact with fqn field, symbol_id generation during insertion
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/05-stable-identity/05-RESEARCH.md

@src/graph/schema.rs
@src/graph/symbols.rs
@src/ingest/mod.rs
@src/output/command.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add fqn field to SymbolFact</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Add fqn (fully-qualified name) field to SymbolFact struct:
    - Add `pub fqn: Option<String>` field after existing fields
    - Update SymbolFact construction in extract_symbol() to set fqn
    - For v1, use simple name-based FQN: name.clone() for top-level symbols
    - Add #[serde(default)] attribute for backward compatibility
    - Do NOT update tests yet (next task)
  </action>
  <verify>cargo check succeeds without test failures</verify>
  <done>SymbolFact has fqn: Option<String> field set during symbol extraction</done>
</task>

<task type="auto">
  <name>Task 2: Add symbol_id field to SymbolNode schema</name>
  <files>src/graph/schema.rs</files>
  <action>
    Add symbol_id field to SymbolNode struct:
    - Add `#[serde(default)] pub symbol_id: Option<String>` as first field after docstring
    - Follow existing pattern: name, kind, kind_normalized, then byte_start/byte_end, etc.
    - Keep field order deterministic for JSON serialization
  </action>
  <verify>cargo check succeeds</verify>
  <done>SymbolNode has symbol_id: Option<String> field</done>
</task>

<task type="auto">
  <name>Task 3: Add symbol_id generation function to symbols module</name>
  <files>src/graph/symbols.rs</files>
  <action>
    Add generate_symbol_id() helper function following Span::generate_id() pattern:
    - Use sha2::{Digest, Sha256}
    - Hash format: language:fqn:span_id (colon-separated)
    - Return first 8 bytes as 16 hex characters
    - Function signature: pub fn generate_symbol_id(language: &str, fqn: &str, span_id: &str) -> String
    - Add module docstring explaining symbol_id stability properties
    - Place function at module level, before impl SymbolOps
  </action>
  <verify>cargo check succeeds</verify>
  <done>generate_symbol_id() function exists with SHA-256 implementation</done>
</task>

<task type="auto">
  <name>Task 4: Update insert_symbol_node to generate and store symbol_id</name>
  <files>src/graph/symbols.rs</files>
  <action>
    Modify SymbolOps::insert_symbol_node() to generate symbol_id:
    1. Detect language using detect_language(&fact.file_path) - default to "unknown"
    2. Generate span_id using Span::generate_id() pattern (reuse from output/command.rs)
       - Format: file_path:byte_start:byte_end
       - 16 hex characters from SHA-256
    3. Get FQN: fact.fqn.as_deref().unwrap_or(&name)
    4. Generate symbol_id using generate_symbol_id(language, fqn, &span_id)
    5. Add symbol_id: Some(symbol_id) to SymbolNode construction
    6. Use or_else() for fallback: format!("<{:?} at {}>", fact.kind, fact.byte_start)
  </action>
  <verify>cargo test --lib graph::symbols passes</verify>
  <done>insert_symbol_node generates stable symbol_id stored in SymbolNode</done>
</task>

<task type="auto">
  <name>Task 5: Add symbol_id determinism tests</name>
  <files>src/graph/symbols.rs</files>
  <action>
    Add unit tests to symbols.rs #[cfg(test)] module:
    - test_symbol_id_deterministic(): same inputs produce same ID
    - test_symbol_id_different_languages(): different language = different ID
    - test_symbol_id_different_fqn(): different FQN = different ID
    - test_symbol_id_different_span(): different span_id = different ID
    - test_symbol_id_format(): verify 16 hex character output
    Follow existing test patterns from output/command.rs span tests
  </action>
  <verify>cargo test passes all new symbol_id tests</verify>
  <done>All symbol_id determinism tests pass</done>
</task>

</tasks>

<verification>
1. cargo check passes without errors
2. cargo test --lib includes passing symbol_id tests
3. SymbolFact has fqn field
4. SymbolNode has symbol_id field
5. insert_symbol_node generates deterministic symbol_id
</verification>

<success_criteria>
1. SymbolNode stores symbol_id generated from (language, fqn, span_id)
2. SymbolFact tracks fqn for symbol_id generation
3. symbol_id is deterministic for same inputs across runs
4. All tests pass with no breaking changes to existing behavior
</success_criteria>

<output>
After completion, create `.planning/phases/05-stable-identity/05-01-SUMMARY.md`
</output>
