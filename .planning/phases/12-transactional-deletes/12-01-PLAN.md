---
phase: 12-transactional-deletes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/ops.rs
autonomous: true

must_haves:
  truths:
    - "delete_file_facts() is wrapped in rusqlite IMMEDIATE transaction"
    - "Transaction commits only after all deletion steps succeed"
    - "Any error during deletion rolls back all changes automatically"
    - "File node deletion is atomic with symbol/reference/call deletion"
  artifacts:
    - path: "src/graph/ops.rs"
      provides: "delete_file_facts() function with transactional delete"
      contains: "transaction_with_behavior(TransactionBehavior::Immediate)"
  key_links:
    - from: "src/graph/ops.rs:delete_file_facts"
      to: "rusqlite::TransactionBehavior::Immediate"
      via: "conn.transaction_with_behavior"
      pattern: "transaction_with_behavior.*Immediate"
---

<objective>
Wrap delete_file_facts() in rusqlite IMMEDIATE transaction following the generation/mod.rs pattern for atomic all-or-nothing deletion.

Purpose: Prevent orphaned records on partial failures by ensuring all delete operations (symbols, references, calls, edges, file node) either all succeed or all roll back together.
Output: Transactional delete_file_facts() that uses IMMEDIATE mode for write locking and automatic rollback on errors.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/generation/mod.rs
@src/graph/ops.rs
@src/graph/schema.rs

# Reference Pattern from generation/mod.rs (lines 106-141):
```rust
pub fn store_chunks(&self, chunks: &[CodeChunk]) -> Result<Vec<i64>> {
    let conn = self.connect()?;

    let tx = conn
        .unchecked_transaction()
        .map_err(|e| anyhow::anyhow!("Failed to start transaction: {}", e))?;

    // ... operations ...

    tx.commit()
        .map_err(|e| anyhow::anyhow!("Failed to commit transaction: {}", e))?;

    Ok(ids)
}
```

# Current delete_file_facts() in ops.rs (lines 177-245):
The function currently performs multiple deletions WITHOUT transaction wrapping:
1. Delete symbol nodes (via DEFINES edges)
2. Delete code chunks
3. Delete file node
4. Delete references
5. Delete calls
6. Delete edges touching deleted entities

Any failure in steps 2-5 could leave orphaned records.
</context>

<tasks>

<task type="auto">
  <name>Wrap delete_file_facts() in IMMEDIATE transaction</name>
  <files>src/graph/ops.rs</files>
  <action>
Modify delete_file_facts() in src/graph/ops.rs (lines 177-245) to use rusqlite IMMEDIATE transaction:

1. At the START of the function (after gathering initial data), get the connection via graph.chunks.connect()
2. Call conn.transaction_with_behavior(TransactionBehavior::Immediate) to start transaction
3. Move ALL deletion operations INSIDE the transaction block:
   - Delete symbol nodes via delete_entity()
   - Delete code chunks via delete_chunks_for_file()
   - Delete file node via delete_entity()
   - Delete references via delete_references_in_file()
   - Delete calls via delete_calls_in_file()
   - Delete edges via delete_edges_touching_entities()
4. At the END, call tx.commit() with proper error mapping
5. If ANY operation fails, the transaction drops and rolls back automatically (Rust's Drop trait)

Use this pattern (similar to generation/mod.rs):
```rust
let conn = graph.chunks.connect()?;

let tx = conn
    .transaction_with_behavior(rusqlite::TransactionBehavior::Immediate)
    .map_err(|e| anyhow::anyhow!("Failed to start delete transaction: {}", e))?;

// All delete operations here...

tx.commit()
    .map_err(|e| anyhow::anyhow!("Failed to commit delete transaction: {}", e))?;
```

Do NOT use unchecked_transaction() - explicitly use TransactionBehavior::Immediate.
Remove from in-memory index AFTER successful commit (not before transaction).
  </action>
  <verify>
Run: cargo test --package magellan --lib graph::tests
Expected: All existing tests still pass (no behavior change for successful deletes)
  </verify>
  <done>
delete_file_facts() begins with transaction_with_behavior(TransactionBehavior::Immediate), all deletions occur within transaction, commit() called at end, and tests pass.
  </done>
</task>

</tasks>

<verification>
1. cargo test --package magellan --lib passes (no regression)
2. Source code shows transaction_with_behavior(TransactionBehavior::Immediate) at start of delete_file_facts
3. Source code shows tx.commit() before return Ok(())
4. graph.files.file_index.remove() occurs AFTER successful commit (not before)
</verification>

<success_criteria>
1. delete_file_facts() uses IMMEDIATE transaction for all deletions
2. Transaction pattern matches generation/mod.rs style
3. All existing tests pass without modification
4. Transaction commit is the final step before returning Ok
</success_criteria>

<output>
After completion, create `.planning/phases/12-transactional-deletes/12-01-SUMMARY.md` with:
- Transaction mode used (IMMEDIATE)
- Lines of code changed
- Test results
- Any unexpected issues encountered
</output>
