---
phase: 12-transactional-deletes
plan: 04
type: execute
wave: 4
depends_on: ["12-01", "12-02", "12-03"]
files_modified:
  - tests/delete_orphan_tests.rs
autonomous: true

must_haves:
  truths:
    - "Orphan detection test confirms no dangling edges after file delete"
    - "validate_graph() passes after successful file deletion"
    - "No ORPHAN_REFERENCE or ORPHAN_CALL errors after delete"
  artifacts:
    - path: "tests/delete_orphan_tests.rs"
      provides: "Orphan detection invariant tests for delete operations"
      min_lines: 100
  key_links:
    - from: "tests/delete_orphan_tests.rs"
      to: "src/graph/validation.rs:validate_graph"
      via: "calling validate_graph after delete operations"
      pattern: "validate_graph.*delete"
    - from: "tests/delete_orphan_tests.rs"
      to: "src/graph/ops.rs:delete_file_facts"
      via: "calling delete_file_facts then checking orphans"
      pattern: "delete_file.*validate"
---

<objective>
Add invariant test that verifies no dangling edges exist after file delete operations.

Purpose: Provide end-to-end verification that delete_file_facts() leaves the graph in a clean state with no orphaned references or calls. This validates the entire transactional delete system.
Output: Comprehensive integration test that creates complex graphs, deletes files, and validates no orphaned records remain.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/12-transactional-deletes/12-01-SUMMARY.md
@.planning/phases/12-transactional-deletes/12-02-SUMMARY.md
@.planning/phases/12-transactional-deletes/12-03-SUMMARY.md
@src/graph/ops.rs
@src/graph/validation.rs

# Existing validation functions (from validation.rs):
- validate_graph() - runs check_orphan_references() and check_orphan_calls()
- check_orphan_references() - finds Reference nodes without REFERENCES edges
- check_orphan_calls() - finds Call nodes without CALLER or CALLS edges

# Orphan types to detect:
1. ORPHAN_REFERENCE - Reference node with no outgoing REFERENCES edge (target symbol deleted)
2. ORPHAN_CALL_NO_CALLER - Call node with no incoming CALLER edge (caller symbol deleted)
3. ORPHAN_CALL_NO_CALLEE - Call node with no outgoing CALLS edge (callee symbol deleted)

# Test scenarios:
1. Delete file that has only local symbols (no cross-file refs/calls)
2. Delete file that is referenced by other files (cross-file references)
3. Delete file that calls symbols from other files (cross-file calls)
4. Delete multiple files in sequence
5. Delete file, then re-index same file (idempotency check)
</context>

<tasks>

<task type="auto">
  <name>Create orphan detection test for delete operations</name>
  <files>tests/delete_orphan_tests.rs</files>
  <action>
Create tests/delete_orphan_tests.rs with comprehensive orphan detection tests:

1. Test: Single file deletion (baseline)
   ```rust
   #[test]
   fn test_delete_single_file_no_orphans() {
       // Create graph with one file containing symbols
       // Delete the file
       // Run validate_graph()
       // Assert: passed == true, errors.is_empty()
   }
   ```

2. Test: Cross-file references (caller deleted)
   ```rust
   #[test]
   fn test_delete_referenced_file_no_orphans() {
       // File A: defines function foo()
       // File B: references foo()
       // Delete File A (the definition)
       // Verify: File B's Reference nodes were also deleted (they belong to File B)
       // Actually: References in File B should REMAIN (they're in File B)
       // But: Their REFERENCES edges point to deleted Symbol from File A
       // This is OK - references can point to non-existent symbols (external refs)
       // validate_graph() might flag these as orphans - check expected behavior
   }
   ```
   NOTE: Clarify expected behavior - should references to deleted symbols be removed?

3. Test: Cross-file calls (caller deleted)
   ```rust
   #[test]
   fn test_delete_calling_file_no_orphans() {
       // File A: defines foo() and bar()
       // File A: foo() calls bar()
       // Delete File A
       // Verify: No orphan Call nodes remain
   }
   ```

4. Test: Multiple file deletion
   ```rust
   #[test]
   fn test_delete_multiple_files_no_orphans() {
       // Create 3 files with cross-references
       // Delete all 3
       // Verify: No orphaned anything
   }
   ```

5. Test: Delete and re-index (idempotency)
   ```rust
   #[test]
   fn test_delete_reindex_no_orphans() {
       // Index a file
       // Delete it
       // Re-index same file (same content)
       // Verify: No orphans, graph is clean
   }
   ```

6. Test: Complex graph with multiple symbol types
   ```rust
   #[test]
   fn test_delete_complex_file_no_orphans() {
       // File with: functions, structs, impls, methods
       // All with references and calls between them
       // Delete file
       // Verify: All entity types and edges cleaned up
   }
   ```

7. Test: Code chunks deletion
   ```rust
   #[test]
   fn test_delete_file_code_chunks_removed() {
       // Index file with multiple symbols (generates chunks)
       // Delete file
       // Direct SQL query: SELECT COUNT(*) FROM code_chunks WHERE file_path = ?
       // Assert: count == 0
   }
   ```

8. Test: Edge cleanup verification
   ```rust
   #[test]
   fn test_delete_file_edges_removed() {
       // Create file with symbols and DEFINES edges
       // Delete file
       // Direct SQL query: SELECT COUNT(*) FROM graph_edges WHERE from_id IN (deleted_ids)
       // Assert: count == 0
   }
   ```

Use the validation module:
```rust
use magellan::graph::validation::validate_graph;

let report = validate_graph(&mut graph).unwrap();
assert!(report.passed, "Graph should have no orphans after delete: {:?}", report.errors);
```

Use in-memory database (":memory:") for test isolation.
  </action>
  <verify>
Run: cargo test --package magellan --test delete_orphan_tests
Expected: All tests pass, no orphaned records detected after any delete operation
  </verify>
  <done>
tests/delete_orphan_tests.rs exists with at least 7 tests covering single/multiple file deletion, cross-file references, calls, re-indexing, and edge/chunk cleanup. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. tests/delete_orphan_tests.rs exists
2. At least 7 distinct test cases covering different delete scenarios
3. Each test calls validate_graph() and asserts report.passed == true
4. Tests check both node deletion and edge deletion
5. Code chunks deletion is verified directly via SQL
6. All tests pass consistently
</verification>

<success_criteria>
1. validate_graph() passes after all successful delete operations
2. No ORPHAN_REFERENCE errors after any delete
3. No ORPHAN_CALL_NO_CALLER or ORPHAN_CALL_NO_CALLEE errors
4. Code chunks are fully deleted for deleted files
5. Edges touching deleted entities are removed
6. Tests cover cross-file reference/call scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/12-transactional-deletes/12-04-SUMMARY.md` with:
- List of test cases created
- Any orphan detection issues found and fixed
- Expected behavior for cross-file references after deletion
- Test results summary
</output>
