---
phase: 12-transactional-deletes
plan: 03
type: execute
wave: 3
depends_on: ["12-01", "12-02"]
files_modified:
  - src/graph/ops.rs
  - tests/delete_transaction_tests.rs
autonomous: true

must_haves:
  truths:
    - "Error injection test causes transaction rollback"
    - "Rollback restores database to pre-delete state"
    - "Partial delete leaves no orphaned records"
  artifacts:
    - path: "tests/delete_transaction_tests.rs"
      provides: "Error injection tests for delete rollback"
      min_lines: 150
  key_links:
    - from: "tests/delete_transaction_tests.rs"
      to: "src/graph/ops.rs:delete_file_facts"
      via: "calling delete_file_facts with error injection"
      pattern: "delete_file_facts.*mock|injection"
---

<objective>
Implement error injection tests that verify transaction rollback works correctly when delete_file_facts() fails partway through.

Purpose: Prove that the IMMEDIATE transaction wrapper from plan 12-01 actually rolls back on error, leaving no orphaned records. Error injection simulates failures at different points in the deletion process.
Output: Comprehensive test suite that injects errors at each deletion step and verifies complete rollback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/12-transactional-deletes/12-01-SUMMARY.md
@.planning/phases/12-transactional-deletes/12-02-SUMMARY.md
@src/graph/ops.rs
@src/graph/validation.rs

# Existing test patterns in validation.rs:
- test_check_orphan_references_with_orphans() manually inserts orphan nodes
- test_validate_graph_integration() tests mixed valid/invalid nodes

# Error injection approach:
Since we cannot easily inject errors into sqlitegraph's internals, we'll test rollback by:
1. Creating a file with symbols, references, and calls
2. Simulating a "partial failure" by manually creating a scenario where deletion would fail
3. Using a modified delete path that returns an error mid-deletion
4. Verifying that all data remains (rollback occurred)

# Alternative: Use a test flag
Add a test-only flag to delete_file_facts that simulates failure at a specific step.
</context>

<tasks>

<task type="auto">
  <name>Create error injection test infrastructure</name>
  <files>tests/delete_transaction_tests.rs</files>
  <action>
Create tests/delete_transaction_tests.rs with error injection tests for delete rollback:

1. Create test infrastructure with a "fail point" enum:
   ```rust
   enum FailPoint {
       AfterSymbolsDeleted,
       AfterReferencesDeleted,
       AfterCallsDeleted,
       AfterChunksDeleted,
   }
   ```

2. Create a test helper that creates a CodeGraph with test data:
   - File node with File { path, hash, ... }
   - Multiple Symbol nodes with DEFINES edges
   - Multiple Reference nodes with REFERENCES edges
   - Multiple Call nodes with CALLER/CALLS edges
   - Code chunks in code_chunks table

3. For each FailPoint variant, create a test:
   ```rust
   #[test]
   fn test_rollback_after_symbols_deleted() {
       // Setup: Create graph with file + symbols + refs + calls + chunks
       // Action: Call delete with failure injection after symbols
       // Verify: All entities still exist (rollback worked)
   }
   ```

4. Use a test-specific approach to inject failure:
   - Option A: Add #[cfg(test)] function to ops.rs that accepts a fail_at parameter
   - Option B: Clone the DB, delete from clone, verify original unchanged
   - Option C: Use a mock wrapper that simulates failure

   RECOMMENDED: Option A - Add test-only helper in ops.rs with #[cfg(test)]:
   ```rust
   #[cfg(test)]
   pub fn delete_file_facts_with_injection(
       graph: &mut CodeGraph,
       path: &str,
       fail_at: Option<FailPoint>,
   ) -> Result<()> {
       // Same as delete_file_facts but returns Err at fail_at
   }
   ```

5. Verify rollback by checking:
   - File node still exists in graph_entities
   - All Symbol nodes still exist
   - All Reference nodes still exist
   - All Call nodes still exist
   - All edges still exist
   - Code chunks still in code_chunks table

6. Add a test for successful delete (no failure) as baseline.

7. Add tests for concurrent deletion scenarios:
   - Delete same file twice (second should be no-op)
   - Delete file while queries are active (verify no inconsistency)

Tests should use in-memory database (":memory:") for isolation.
  </action>
  <verify>
Run: cargo test --package magellan --test delete_transaction_tests
Expected: All rollback tests pass, proving transaction rollback works
  </verify>
  <done>
tests/delete_transaction_tests.rs exists with FailPoint enum, delete_file_facts_with_injection helper, rollback test for each FailPoint variant, and all tests pass.
  </done>
</task>

<task type="auto">
  <name>Add test-only delete helper with fail points</name>
  <files>src/graph/ops.rs</files>
  <action>
Add to src/graph/ops.rs (inside #[cfg(test)] module or at end of file):

```rust
#[cfg(test)]
pub mod test_helpers {
    use super::*;

    #[derive(Debug, Clone, Copy)]
    pub enum FailPoint {
        AfterSymbolsDeleted,
        AfterReferencesDeleted,
        AfterCallsDeleted,
        AfterChunksDeleted,
        BeforeFileDeleted,
    }

    pub fn delete_file_facts_with_injection(
        graph: &mut CodeGraph,
        path: &str,
        fail_at: Option<FailPoint>,
    ) -> Result<()> {
        // Copy logic from delete_file_facts but inject errors:
        // 1. Start transaction
        // 2. Delete symbols
        //    if fail_at == Some(AfterSymbolsDeleted) { return Err(...); }
        // 3. Delete references
        //    if fail_at == Some(AfterReferencesDeleted) { return Err(...); }
        // 4. Delete calls
        //    if fail_at == Some(AfterCallsDeleted) { return Err(...); }
        // 5. Delete chunks
        //    if fail_at == Some(AfterChunksDeleted) { return Err(...); }
        // 6. Delete file
        //    if fail_at == Some(BeforeFileDeleted) { return Err(...); }
        // 7. Commit
    }
}
```

This keeps production code clean while enabling thorough testing.
  </action>
  <verify>
Run: cargo check --package magellan
Expected: No compilation errors, test_helpers module accessible from tests
  </verify>
  <done>
src/graph/ops.rs has #[cfg(test)] module with FailPoint enum and delete_file_facts_with_injection function that mirrors delete_file_facts logic with error injection.
  </done>
</task>

</tasks>

<verification>
1. tests/delete_transaction_tests.rs exists
2. FailPoint enum has variants for each deletion step
3. Each fail point has a corresponding test
4. Tests verify all data still exists after rollback
5. Successful delete test passes as baseline
6. cargo test --test delete_transaction_tests passes all tests
</verification>

<success_criteria>
1. At least 5 rollback tests (one per FailPoint variant)
2. Each test verifies all entity types remain after rollback
3. Test database state is checked directly via SQL queries
4. Error injection returns distinct error messages
5. All tests pass consistently
</success_criteria>

<output>
After completion, create `.planning/phases/12-transactional-deletes/12-03-SUMMARY.md` with:
- FailPoint enum definition
- Number of rollback tests created
- Any issues with rollback verification
- Test results summary
</output>
