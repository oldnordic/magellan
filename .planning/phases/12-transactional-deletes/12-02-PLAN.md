---
phase: 12-transactional-deletes
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - src/graph/ops.rs
  - src/graph/references.rs
  - src/graph/call_ops.rs
autonomous: true

must_haves:
  truths:
    - "Row-count assertions verify each deletion step"
    - "Return value includes counts of deleted items"
    - "Assertions catch if derived data is not deleted"
  artifacts:
    - path: "src/graph/ops.rs"
      provides: "delete_file_facts() with row-count assertions"
      contains: "assert_eq!"
    - path: "src/graph/references.rs"
      provides: "delete_references_in_file() returning deleted count"
      exports: ["delete_references_in_file"]
    - path: "src/graph/call_ops.rs"
      provides: "delete_calls_in_file() returning deleted count"
      exports: ["delete_calls_in_file"]
  key_links:
    - from: "delete_file_facts"
      to: "delete_references_in_file"
      via: "function call with count verification"
      pattern: "assert_eq!.*delete_references"
    - from: "delete_file_facts"
      to: "delete_calls_in_file"
      via: "function call with count verification"
      pattern: "assert_eq!.*delete_calls"
---

<objective>
Add row-count assertions to verify all derived data is deleted during delete_file_facts() operations.

Purpose: Ensure that when a file is deleted, all related symbols, references, calls, and edges are actually removed from the database. Row-count assertions provide verification that deletions completed successfully.
Output: delete_file_facts() with assertions proving all derived data was deleted, returning detailed deletion statistics.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/12-transactional-deletes/12-01-SUMMARY.md
@src/graph/ops.rs
@src/graph/references.rs
@src/graph/call_ops.rs

# Current deletion flow (after plan 12-01 transaction wrapping):
1. Delete symbol nodes (collect IDs, sort, delete each)
2. Delete code chunks (delete_chunks_for_file returns count)
3. Delete file node
4. Delete references (delete_references_in_file returns count)
5. Delete calls (delete_calls_in_file returns count)
6. Delete edges touching deleted entities

# Problem:
Currently, delete_references_in_file() and delete_calls_in_file() return deleted counts, but delete_file_facts() uses:
```rust
let _ = (reference_deleted, call_deleted);  // Silences unused warnings
```

This means we don't VERIFY that deletions actually occurred.
</context>

<tasks>

<task type="auto">
  <name>Add row-count assertions to delete_file_facts()</name>
  <files>src/graph/ops.rs</files>
  <action>
Modify delete_file_facts() in src/graph/ops.rs to add row-count verification:

1. BEFORE the transaction starts, COUNT the items to be deleted:
   - Count DEFINES edges from file to symbols (represents symbols to delete)
   - Count Reference nodes with matching file_path
   - Count Call nodes with matching file_path
   - Count code_chunks with matching file_path

2. INSIDE the transaction, AFTER each delete operation, ASSERT the count:
   ```rust
   let symbols_deleted = symbol_ids_sorted.len();
   let chunks_deleted = graph.chunks.delete_chunks_for_file(path)?;
   assert_eq!(chunks_deleted, expected_chunks, "Code chunks count mismatch for {}", path);

   let references_deleted = graph.references.delete_references_in_file(path)?;
   assert_eq!(references_deleted, expected_references, "References count mismatch for {}", path);

   let calls_deleted = graph.calls.delete_calls_in_file(path)?;
   assert_eq!(calls_deleted, expected_calls, "Calls count mismatch for {}", path);
   ```

3. For edges deleted, verify that the count matches expected:
   - Expected edges = (symbols_deleted * 1 for DEFINES) + references_deleted * REFERENCES_edges + calls_deleted * 2 edges (CALLER + CALLS)
   - Use assert_eq! with a tolerance for edge counting (exact count may vary due to sqlitegraph's internal edge handling)

4. Add a new return type or modify to return deletion statistics:
   ```rust
   pub struct DeleteResult {
       pub symbols_deleted: usize,
       pub references_deleted: usize,
       pub calls_deleted: usize,
       pub chunks_deleted: usize,
       pub edges_deleted: usize,
   }
   ```

5. Update delete_file() wrapper to return the new DeleteResult.

6. Update reconciler_file_path() to handle the new return type (ignore or use the stats).

DO NOT delete assertions in production code - these are critical data integrity checks.
  </action>
  <verify>
Run: cargo test --package magellan --lib graph::tests test_delete
Expected: Tests pass, and assertions verify correct deletion counts
  </verify>
  <done>
delete_file_facts() counts expected items before deletion, asserts counts after each deletion step, returns DeleteResult with all counts, and existing tests pass.
  </done>
</task>

</tasks>

<verification>
1. cargo test --package magellan --lib passes
2. Source code shows count queries before transaction (or count collection during iteration)
3. Source code shows assert_eq! after each delete operation
4. DeleteResult struct is defined and returned
5. delete_file() returns Result<DeleteResult> or similar
</verification>

<success_criteria>
1. Row-count assertions exist for symbols, references, calls, chunks
2. Edge deletion is verified (exact or approximate count)
3. DeleteResult struct provides deletion statistics
4. All tests pass with assertions enabled
5. Failed assertions panic with descriptive messages including file path
</success_criteria>

<output>
After completion, create `.planning/phases/12-transactional-deletes/12-02-SUMMARY.md` with:
- DeleteResult struct definition
- Assertions added (with line numbers)
- Any count discrepancies found and fixed
- Test results
</output>
