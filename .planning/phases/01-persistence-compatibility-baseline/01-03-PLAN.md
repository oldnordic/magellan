---
phase: 01-persistence-compatibility-baseline
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/graph/db_compat.rs
  - src/graph/mod.rs
  - src/generation/mod.rs
  - src/main.rs
  - tests/phase1_persistence_compatibility.rs
autonomous: true
must_haves:
  truths:
    - "When a user opens a DB with --db <FILE>, Magellan records a schema compatibility version in the database."
    - "If a DB is incompatible, Magellan exits with a deterministic, normalized error without mutating sqlite_master (no new tables created)."
    - "CLI refusal behavior is verifiable end-to-end (command exits non-zero + stable error message) for incompatible DBs."
  artifacts:
    - path: "tests/phase1_persistence_compatibility.rs"
      provides: "regression tests for DB-02: schema version recorded + deterministic refusal + no partial mutation"
    - path: "src/graph/db_compat.rs"
      provides: "magellan_meta schema ensure + version read/verify + DbCompatError normalization"
  key_links:
    - from: "src/graph/mod.rs"
      to: "magellan_meta"
      via: "ensure_magellan_meta after sqlitegraph open"
      pattern: "magellan_meta"
    - from: "src/main.rs"
      to: "CodeGraph::open"
      via: "CLI surfaces DbCompatError as deterministic message"
      pattern: "DB_COMPAT"
    - from: "tests/phase1_persistence_compatibility.rs"
      to: "magellan status --db"
      via: "spawns CLI and asserts refusal behavior"
      pattern: "status"
---

<objective>
Record Magellan-side schema versioning metadata and add regression tests proving Phase 1 behaviors (DB-02).

Purpose: Make DB compatibility explicit and machine-checkable by storing Magellan’s own schema version (and the sqlitegraph schema version it was validated against) and proving the "no partial mutation" guarantee with tests.
Output: `magellan_meta` table (versioned) + tests that validate open behavior for new DBs and incompatible DBs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-persistence-compatibility-baseline/01-RESEARCH.md
@src/graph/mod.rs
@src/generation/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Magellan-owned metadata table (magellan_meta) with schema version</name>
  <files>src/graph/db_compat.rs, src/graph/mod.rs</files>
  <action>
- Extend the Phase 1 DB compatibility module to include Magellan-owned schema versioning.

Design constraints:
- Do NOT overload sqlitegraph’s `graph_meta` for Magellan-specific versioning (sqlitegraph owns it).
- Because sqlitegraph’s `Connection` is private, use a separate `rusqlite::Connection` opened on the same DB path (same approach as ChunkStore).
- Ensure ordering: only create/update `magellan_meta` AFTER sqlitegraph preflight has succeeded and AFTER sqlitegraph open has succeeded (no side-table writes on incompatible DBs).

Schema recommendation (keep minimal but explicit):
- Table: `magellan_meta`
- Single-row, `id=1`
- Columns:
  - `magellan_schema_version INTEGER NOT NULL`
  - `sqlitegraph_schema_version INTEGER NOT NULL`
  - `created_at INTEGER NOT NULL` (unix epoch seconds) OR omit if not needed

Behavior:
- On new DB open: insert row id=1 with current versions.
- On existing DB open:
  - If table missing: create and insert row.
  - If table exists:
    - If stored `magellan_schema_version` != current expected: refuse to proceed with clear error (Phase 1 compatibility gate).
    - If stored `sqlitegraph_schema_version` != expected: refuse (defensive; should not happen if preflight enforced).

Pick and define `MAGELLAN_SCHEMA_VERSION` constant (start at 1) in a suitable module and use it in checks.

Update `CodeGraph::open()` to call `ensure_magellan_meta(...)` in the correct place.
  </action>
  <verify>
- `cargo test --workspace`
  </verify>
  <done>
- Opening a DB results in `magellan_meta` existing with a single row (id=1) containing the current Magellan schema version and sqlitegraph schema version.
- If versions mismatch, open fails deterministically before any additional writes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Strengthen tests + add CLI-level deterministic refusal verification</name>
  <files>src/generation/mod.rs, src/main.rs, tests/phase1_persistence_compatibility.rs</files>
  <action>
Ordering gate
- Ensure `ChunkStore::ensure_schema()` is only called after:
  1) sqlitegraph preflight succeeds (existing DB)
  2) sqlitegraph open succeeds
  3) magellan_meta has been checked/created successfully

If the current call order in `CodeGraph::open()` violates this, adjust accordingly.

Hard requirement: error normalization test matrix
Add/extend integration tests in `tests/phase1_persistence_compatibility.rs` covering ALL of the following (no optionality):

A) "New DB records schema versions":
- Create a temp directory and choose a new DB file path.
- Call `CodeGraph::open(db_path)`.
- Using `rusqlite`, assert:
  - `graph_meta` exists
  - `graph_meta` has row `id=1`
  - `magellan_meta` exists and has row id=1 with expected `magellan_schema_version` and expected `sqlitegraph_schema_version`.
  - Expected sqlitegraph schema version used in assertions MUST come from `sqlitegraph::schema::SCHEMA_VERSION`.

B) "Not a SQLite database / corrupt file is refused deterministically without mutation":
- Create a temp file (non-SQLite bytes) at `db_path`.
- Snapshot file size and content hash (canonical). You MAY record timestamps (`metadata.modified()`) as *debug-only* if available, but tests must not depend on timestamps for correctness. Also snapshot directory listing.
- Call `CodeGraph::open(db_path)` and assert:
  - It returns error matching the normalized variant (e.g., contains `DB_COMPAT: not a sqlite database`).
  - The file was NOT replaced with a SQLite DB (size/hash unchanged).

C) "Missing graph_meta table is refused deterministically without mutation":
- Create a valid SQLite DB file with a dummy table but NO `graph_meta`.
- Snapshot `sqlite_master` table names (canonical no-mutation check). Optionally also snapshot DB file size/hash for debugging; timestamps are debug-only.
- Call `CodeGraph::open(db_path)` and assert:
  - Error contains stable marker (e.g., `DB_COMPAT: missing graph_meta`).
  - Table list unchanged.

D) "Missing graph_meta id=1 row is refused deterministically without mutation":
- Create SQLite DB with `graph_meta(id INTEGER PRIMARY KEY CHECK (id = 1), schema_version INTEGER NOT NULL)` but DO NOT insert id=1.
- Snapshot table names via `sqlite_master` (canonical no-mutation check). Optionally also snapshot DB file size/hash for debugging; timestamps are debug-only.
- Call `CodeGraph::open(db_path)` and assert:
  - Error contains stable marker (e.g., `DB_COMPAT: missing graph_meta row id=1`).
  - Table list unchanged.

E) "Schema version mismatch (older/newer) is refused deterministically without mutation":
- Create SQLite DB with `graph_meta` and insert row id=1 with a wrong schema_version.
- Use two cases:
  - older: expected-1
  - newer: expected+1
- For each, call `CodeGraph::open` and assert:
  - Error contains stable marker and includes both found and expected values.
  - `sqlite_master` table list unchanged (canonical no-mutation check). Optionally also assert DB file size/hash unchanged for debugging; timestamps are debug-only.

Hard requirement: CLI-level verify step (warning closure)
- Ensure CLI returns normalized errors (no raw rusqlite strings) by mapping `DbCompatError` into a stable top-level error message.
- Add a test that spawns the compiled binary (or uses `assert_cmd` if available in dev-deps) to run:
  - `magellan status --db <incompatible_db_path>`
  - Assert exit code is non-zero.
  - Assert stderr contains the deterministic prefix and expected message.

No partial mutation guarantee
- For ALL failing cases above, assert that Magellan does not create new tables and does not replace/overwrite non-sqlite files.
  </action>
  <verify>
- `cargo test --workspace`
  </verify>
  <done>
- Tests cover all error normalization cases (not sqlite/corrupt, missing graph_meta, missing id=1 row, older/newer schema version) and prove no partial mutation.
- CLI refusal is demonstrated with a deterministic failure message and non-zero exit code.
  </done>
</task>

</tasks>

<verification>
- Run `cargo test --workspace` and confirm the new Phase 1 tests pass.
- Manually sanity check: `cargo run -- status --db /tmp/magellan_phase1_test.db` after a failing open attempt should not show partial tables for incompatible DBs.
</verification>

<success_criteria>
- Phase 1 roadmap success criteria all satisfied:
  1) Local sqlitegraph checkout used (Plan 01)
  2) Schema version(s) recorded in DB (`graph_meta` + `magellan_meta`)
  3) Incompatible DBs refused without partial mutation (tests prove).
</success_criteria>

<output>
After completion, create `.planning/phases/01-persistence-compatibility-baseline/01-03-SUMMARY.md`.
</output>
