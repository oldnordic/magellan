---
phase: 01-persistence-compatibility-baseline
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/graph/mod.rs
  - src/graph/db_compat.rs
autonomous: true
must_haves:
  truths:
    - "Opening an existing DB performs a read-only compatibility preflight before any writes occur."
    - "If the DB is incompatible (not sqlitegraph or wrong schema version), Magellan refuses to open with a deterministic, normalized error and does not partially mutate the DB."
    - "Compatibility checks compare the DB's graph_meta.schema_version against the expected sqlitegraph schema version for this build."
  artifacts:
    - path: "src/graph/db_compat.rs"
      provides: "read-only sqlitegraph DB compatibility preflight + deterministic expected-version retrieval + normalized error mapping"
    - path: "src/graph/mod.rs"
      provides: "CodeGraph::open uses preflight before sqlitegraph::SqliteGraph::open"
  key_links:
    - from: "src/graph/db_compat.rs"
      to: "sqlitegraph::schema::SCHEMA_VERSION"
      via: "preferred expected schema version constant"
      pattern: "schema::SCHEMA_VERSION"
    - from: "src/graph/db_compat.rs"
      to: "graph_meta.schema_version"
      via: "fallback expected-version retrieval via raw SQL on a sqlitegraph-created snapshot"
      pattern: "SELECT schema_version FROM graph_meta"
    - from: "src/graph/mod.rs"
      to: "src/graph/db_compat.rs"
      via: "preflight call before opening sqlitegraph"
      pattern: "preflight"
    - from: "src/graph/mod.rs"
      to: "sqlitegraph::SqliteGraph::open"
      via: "ONLY after preflight success"
      pattern: "SqliteGraph::open"
---

<objective>
Add a deterministic two-phase DB open (read-only preflight, then mutating open) so incompatible databases are refused without partial mutation (DB-02 part: compatibility gate).

Purpose: Prevent sqlitegraph schema creation/migrations (and Magellan side-table writes) from running on DBs that are not known-compatible.
Output: `src/graph/db_compat.rs` preflight module + `CodeGraph::open()` refactor to enforce the compatibility gate.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-persistence-compatibility-baseline/01-RESEARCH.md
@src/graph/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement read-only sqlitegraph compatibility preflight + deterministic error normalization</name>
  <files>src/graph/db_compat.rs</files>
  <action>
- Create `src/graph/db_compat.rs` and implement a small, testable preflight API used by `CodeGraph::open()`.

Hard requirement: expected sqlitegraph schema version source (with deterministic contingency)
- Expected schema version MUST come from sqlitegraph public API, not a hardcoded value.
- Preferred (compile-time, non-I/O): use `sqlitegraph::schema::SCHEMA_VERSION` as the authoritative expected version.
- Contingency branch (ONLY if `schema::SCHEMA_VERSION` is not usable from Magellan due to visibility/re-export/version drift):
  - Deterministically derive the expected schema version by querying sqlitegraph-created schema metadata (without hardcoding).
  - Implementation constraint: this MUST be deterministic and MUST NOT depend on unstable error strings.
  - One acceptable approach (IMPORTANT: this does *not* touch the target DB path):
    1) Create a temporary on-disk sqlite file in a tempdir (not `:memory:`) and open it with `sqlitegraph::SqliteGraph::open(tmp_path)` ONLY to allow sqlitegraph to create its schema.
    2) Close the sqlitegraph handle.
    3) Re-open that temp DB using `rusqlite::Connection::open_with_flags(...READ_ONLY...)`.
    4) Run `SELECT schema_version FROM graph_meta WHERE id=1` and use that value as `expected`.
    5) Clean up the temp file.
  - Rationale: This reads sqlitegraph's own schema metadata rather than duplicating constants.
  - Safety note: this contingency MUST NOT be used as the primary path because it incurs I/O and involves a mutating open of a throwaway DB.
- Alternative fallback (NOT for preflight): `sqlitegraph::SqliteGraph::schema_version()` may be used only after preflight has already succeeded (post-gate) because it requires opening a SqliteGraph handle and may mutate/ensure schema.
- Do NOT duplicate schema version logic in Magellan.

Preflight behavior
- If `db_path` is exactly `:memory:`: treat as "new DB" (compat ok) and do not attempt filesystem checks.
- If the DB file does not exist: treat as "new DB" (compat ok) because sqlitegraph will create schema later.
- If the DB file exists:
  1) Open it with `rusqlite::Connection::open_with_flags` using READ_ONLY flags to guarantee no mutations during preflight.
  2) Run deterministic detection in this order (no reliance on rusqlite error strings):
     a) Not a SQLite database / corrupt file (STRUCTURED matching only — ban message-string matching):
        - Attempt a simple query like `SELECT 1;` (or a `sqlite_master` query) after opening READ_ONLY.
        - If the query returns an error, classify using *rusqlite error variants + SQLite (extended) error codes*:
          - Match `rusqlite::Error::SqliteFailure(sql_err, _maybe_msg)` and inspect:
            - `sql_err.code` (stable enum, maps to SQLite primary error code; also note numeric values for test/debug)
            - `sql_err.extended_code` (stable i32; SQLite extended error code)
          - Map deterministically:
            - If `sql_err.code == rusqlite::ErrorCode::NotADatabase` (SQLITE_NOTADB = 26): return `DbCompatError::NotSqlite { path }`.
            - If `sql_err.code == rusqlite::ErrorCode::Corrupt` (SQLITE_CORRUPT = 11) OR `sql_err.extended_code` indicates a CORRUPT* extended code: return `DbCompatError::CorruptSqlite { path, code: sql_err.code, extended_code: sql_err.extended_code }` (or equivalent normalized variant).
            - Otherwise: return a normalized `DbCompatError::PreflightSqliteFailure { path, code: sql_err.code, extended_code: sql_err.extended_code }` (or equivalent).
        - Forbidden: any `match`/`if` on `e.to_string()` / `msg.contains("not a database")` / localized error message text.
     b) Missing sqlitegraph meta table:
        - Query `sqlite_master` for table `graph_meta`.
        - If missing: return `DbCompatError::MissingGraphMeta { path }`.
     c) Missing required columns:
        - Query `PRAGMA table_info(graph_meta)` and confirm a `schema_version` column exists.
        - If missing: return `DbCompatError::GraphMetaMissingSchemaVersion { path }`.
     d) Missing id=1 row:
        - Query `SELECT schema_version FROM graph_meta WHERE id=1` using `OptionalExtension`.
        - If row missing: return `DbCompatError::MissingGraphMetaRow { path, id: 1 }`.
     e) Version mismatch (exact match required in Phase 1):
         - Determine `expected` using the contingency rules above (prefer `sqlitegraph::schema::SCHEMA_VERSION`; otherwise a deterministic sqlitegraph-created snapshot + READ_ONLY raw SQL on `graph_meta`).
         - Compare found vs `expected`.
         - If mismatch: return `DbCompatError::SqliteGraphSchemaMismatch { path, found, expected }`.

Error normalization output
- Define a `DbCompatError` enum (or equivalent) and implement `Display` so user-facing errors are deterministic and stable.
- Do NOT bubble raw `rusqlite::Error` strings into CLI output.
- Ensure every failure path includes a stable prefix (e.g., `DB_COMPAT:`) so tests can assert on it.

No mutation guarantees
- Do NOT call `sqlitegraph::SqliteGraph::open(db_path)` on the *target DB* in preflight.
  - Exception: the contingency path may call `sqlitegraph::SqliteGraph::open(tmp_path)` only on a throwaway temp DB created for the sole purpose of reading sqlitegraph’s own `graph_meta.schema_version`.
- Use READ_ONLY open flags for all connections to the target DB during preflight.
- Keep error mapping purely based on query results / structured error kinds / numeric error codes (SQLite primary + extended codes).
  </action>
  <verify>
- `cargo test --workspace` (compile + unit tests)
  </verify>
  <done>
- `db_compat::preflight_*` (or equivalent) can detect:
  - non-existent DB -> OK(new)
  - existing DB missing graph_meta -> Err(not sqlitegraph)
  - existing DB with mismatched schema_version -> Err(incompatible)
- No sqlitegraph APIs that mutate schema are called during preflight.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor CodeGraph::open to enforce two-phase open</name>
  <files>src/graph/mod.rs</files>
  <action>
- Refactor `CodeGraph::open()` so that:
  1) It runs the read-only preflight for file-based DBs BEFORE doing any writes.
  2) Only if preflight is OK does it proceed to call `sqlitegraph::SqliteGraph::open()`.
  3) Only AFTER sqlitegraph open succeeds does it initialize Magellan side tables (ChunkStore schema, magellan meta in next plan).

Specifically ensure this ordering in the function:
- preflight(db_path)  -> may return error
- sqlitegraph::SqliteGraph::open(db_path)
- (later) ChunkStore::ensure_schema()

This ordering is the core of "no partial mutation": incompatible DBs should fail before sqlitegraph ensure_schema/migrations and before `code_chunks` table creation.

Keep behavior compatibility:
- Existing call sites (`status`, `watch`, `query`, etc.) should continue working with no interface changes.
- `:memory:` usage in tests should continue working.
  </action>
  <verify>
- `cargo test --workspace`
- `cargo run -- status --db /tmp/magellan_phase1_test.db` prints counts (ensures open still works end-to-end)
  </verify>
  <done>
- `CodeGraph::open()` refuses incompatible existing DBs before any schema/table writes.
- All existing tests still compile and pass.
  </done>
</task>

</tasks>

<verification>
- Confirm by code inspection that `ChunkStore::ensure_schema()` is not reachable before preflight completes.
- Confirm errors are deterministic (include found/expected schema versions).
</verification>

<success_criteria>
- Phase 1 success criteria #3 is implementable: incompatible/older DBs are rejected without partial mutation.
</success_criteria>

<output>
After completion, create `.planning/phases/01-persistence-compatibility-baseline/01-02-SUMMARY.md`.
</output>
