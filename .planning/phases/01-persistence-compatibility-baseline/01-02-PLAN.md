---
phase: 01-persistence-compatibility-baseline
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/graph/mod.rs
  - src/graph/db_compat.rs
autonomous: true
must_haves:
  truths:
    - "Opening an existing DB performs a read-only compatibility preflight before any writes occur."
    - "If the DB is incompatible (not sqlitegraph or wrong schema version), Magellan refuses to open with a clear error and does not partially mutate the DB."
  artifacts:
    - path: "src/graph/db_compat.rs"
      provides: "read-only sqlitegraph DB compatibility preflight"
    - path: "src/graph/mod.rs"
      provides: "CodeGraph::open uses preflight before sqlitegraph::SqliteGraph::open"
  key_links:
    - from: "src/graph/mod.rs"
      to: "src/graph/db_compat.rs"
      via: "preflight call before opening sqlitegraph"
      pattern: "preflight"
    - from: "src/graph/mod.rs"
      to: "sqlitegraph::SqliteGraph::open"
      via: "ONLY after preflight success"
      pattern: "SqliteGraph::open"
---

<objective>
Add a deterministic two-phase DB open (read-only preflight, then mutating open) so incompatible databases are refused without partial mutation (DB-02 part: compatibility gate).

Purpose: Prevent sqlitegraph schema creation/migrations (and Magellan side-table writes) from running on DBs that are not known-compatible.
Output: `src/graph/db_compat.rs` preflight module + `CodeGraph::open()` refactor to enforce the compatibility gate.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-persistence-compatibility-baseline/01-RESEARCH.md
@src/graph/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement read-only sqlitegraph compatibility preflight</name>
  <files>src/graph/db_compat.rs</files>
  <action>
- Create `src/graph/db_compat.rs` and implement a small, testable preflight API used by `CodeGraph::open()`.

Preflight requirements (from Phase 1 research):
- If `db_path` is exactly `:memory:`: treat as "new DB" (compat ok) and do not attempt filesystem checks.
- If the DB file does not exist: treat as "new DB" (compat ok) because sqlitegraph will create schema later.
- If the DB file exists:
  1) Open it with `rusqlite::Connection::open_with_flags` using READ_ONLY flags to guarantee no mutations during preflight.
  2) Check `sqlite_master` for table `graph_meta`.
     - If missing: return a clear error like "Not a sqlitegraph database (missing graph_meta)".
  3) Read `graph_meta.schema_version` for `id=1`.
  4) Compare to the sqlitegraph schema version Magellan was built against.
     - Use an authoritative value from the sqlitegraph crate (verify in code): either a constant (e.g. `sqlitegraph::schema::SCHEMA_VERSION`) or an accessor.
  5) If version mismatches: return a deterministic error indicating found vs expected and that Magellan refuses to open.

Notes / constraints:
- Do NOT call `sqlitegraph::SqliteGraph::open()` in preflight.
- Keep error messages deterministic and explicit (no OS-dependent formatting).
  </action>
  <verify>
- `cargo test --workspace` (compile + unit tests)
  </verify>
  <done>
- `db_compat::preflight_*` (or equivalent) can detect:
  - non-existent DB -> OK(new)
  - existing DB missing graph_meta -> Err(not sqlitegraph)
  - existing DB with mismatched schema_version -> Err(incompatible)
- No sqlitegraph APIs that mutate schema are called during preflight.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor CodeGraph::open to enforce two-phase open</name>
  <files>src/graph/mod.rs</files>
  <action>
- Refactor `CodeGraph::open()` so that:
  1) It runs the read-only preflight for file-based DBs BEFORE doing any writes.
  2) Only if preflight is OK does it proceed to call `sqlitegraph::SqliteGraph::open()`.
  3) Only AFTER sqlitegraph open succeeds does it initialize Magellan side tables (ChunkStore schema, magellan meta in next plan).

Specifically ensure this ordering in the function:
- preflight(db_path)  -> may return error
- sqlitegraph::SqliteGraph::open(db_path)
- (later) ChunkStore::ensure_schema()

This ordering is the core of "no partial mutation": incompatible DBs should fail before sqlitegraph ensure_schema/migrations and before `code_chunks` table creation.

Keep behavior compatibility:
- Existing call sites (`status`, `watch`, `query`, etc.) should continue working with no interface changes.
- `:memory:` usage in tests should continue working.
  </action>
  <verify>
- `cargo test --workspace`
- `cargo run -- status --db /tmp/magellan_phase1_test.db` prints counts (ensures open still works end-to-end)
  </verify>
  <done>
- `CodeGraph::open()` refuses incompatible existing DBs before any schema/table writes.
- All existing tests still compile and pass.
  </done>
</task>

</tasks>

<verification>
- Confirm by code inspection that `ChunkStore::ensure_schema()` is not reachable before preflight completes.
- Confirm errors are deterministic (include found/expected schema versions).
</verification>

<success_criteria>
- Phase 1 success criteria #3 is implementable: incompatible/older DBs are rejected without partial mutation.
</success_criteria>

<output>
After completion, create `.planning/phases/01-persistence-compatibility-baseline/01-02-SUMMARY.md`.
</output>
