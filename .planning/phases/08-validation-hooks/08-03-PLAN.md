---
phase: 08-validation-hooks
plan: 03
type: execute
wave: 3
depends_on: [08-01, 08-02]
files_modified:
  - src/main.rs
autonomous: false
must_haves:
  truths:
    - "CLI accepts --validate flag to enable validation mode"
    - "CLI accepts --validate-only flag to run validation without indexing"
    - "Pre-run validation runs before indexing when --validate is set"
    - "Post-run validation runs after indexing when --validate is set"
    - "Validation failures exit with code 1 and output JSON in JSON mode"
    - "Validation results include execution_id for correlation"
  artifacts:
    - path: "src/main.rs"
      provides: "CLI flag parsing and validation hook integration"
      min_lines: 100
  key_links:
    - from: "CLI flags"
      to: "validation module"
      via: "Call validate_graph() and pre_run_validate() based on flags"
      pattern: "validate.*=.*matches"
    - from: "validation output"
      to: "JsonResponse<T>"
      via: "Wrap ValidationResponse in JsonResponse for JSON mode"
      pattern: "JsonResponse::new"
    - from: "validation execution"
      to: "ExecutionTracker"
      via: "Track validation run with execution_id"
      pattern: "tracker\\.(start|finish|set_error)"
---

<objective>
Integrate validation hooks into CLI with --validate and --validate-only flags.

Purpose: Allow users to enable validation and receive structured diagnostics when invariants fail.
Output: CLI flag parsing and validation integration with proper exit codes and JSON output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/08-validation-hooks/08-CONTEXT.md
@.planning/phases/08-validation-hooks/08-RESEARCH.md

@src/main.rs
@src/graph/validation.rs
@src/output/command.rs
@.planning/phases/08-validation-hooks/08-01-SUMMARY.md
@.planning/phases/08-validation-hooks/08-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --validate and --validate-only flags to index command</name>
  <files>src/main.rs</files>
  <action>
    Update the Command enum and parse_args() function to support validation flags.

    1. Update Command::Index variant to include validate and validate_only fields:
       Change from:
       ```rust
       Index { db_path: PathBuf, root: PathBuf, output: OutputFormat, ... }
       ```
       To:
       ```rust
       Index { db_path: PathBuf, root: PathBuf, output: OutputFormat, validate: bool, validate_only: bool, ... }
       ```

    2. In parse_args() Index branch, add flag parsing:
       - "--validate" sets validate = true
       - "--validate-only" sets validate_only = true

    Follow the existing flag parsing pattern (see --output flag parsing around line 400-450).

    IMPORTANT: --validate-only implies validate=true, so set validate = true if validate_only is true.
  </action>
  <verify>
    cargo build 2>&1 | grep -E "(error|warning|unused)" || echo "CLI flags compile"
  </verify>
  <done>
    Command::Index includes validate and validate_only fields.
    --validate and --validate-only flags are parsed correctly.
    --validate-only implies validate=true.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement pre-run validation hook in run_index</name>
  <files>src/main.rs</files>
  <action>
    Add pre-run validation to run_index() function.

    After ExecutionTracker::new() and tracker.start(), add:

    ```rust
    // Pre-run validation if enabled
    if validate || validate_only {
        let input_paths = vec![root.clone()];
        match magellan::graph::validation::pre_run_validate(&db_path, &root, &input_paths) {
            Ok(report) if !report.passed => {
                tracker.set_error(format!("Pre-validation failed: {} errors", report.errors.len()));
                tracker.finish(&graph)?;

                if output_format == OutputFormat::Json {
                    let response = magellan::output::ValidationResponse {
                        passed: false,
                        error_count: report.errors.len(),
                        errors: report.errors.into_iter().map(|e| magellan::output::ValidationError {
                            code: e.code,
                            message: e.message,
                            entity_id: e.entity_id,
                            details: e.details,
                        }).collect(),
                        warning_count: 0,
                        warnings: vec![],
                    };
                    let json_response = magellan::output::JsonResponse::new(response, tracker.exec_id());
                    magellan::output::output_json(&json_response)?;
                }
                return ExitCode::from(1);
            }
            Ok(_) => {}
            Err(e) => {
                tracker.set_error(format!("Pre-validation error: {}", e));
                tracker.finish(&graph)?;
                return ExitCode::from(1);
            }
        }
    }

    // If validate-only, run post-validation and exit
    if validate_only {
        // Task 3 will implement this
        return ExitCode::SUCCESS;
    }
    ```

    Place this after the existing progress callback setup and before the scan_directory call.

    Note: We construct ValidationResponse directly since From trait requires module types.
  </action>
  <verify>
    cargo build 2>&1
  </verify>
  <done>
    Pre-run validation executes before indexing when --validate or --validate-only is set.
    Pre-validation failures output JSON in JSON mode and exit with code 1.
    Pre-validation passes allow indexing to continue.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement --validate-only and post-run validation</name>
  <files>src/main.rs</files>
  <action>
    Implement --validate-only mode and post-run validation.

    1. Replace the "return ExitCode::SUCCESS" placeholder from Task 2 with full validate-only logic:

    ```rust
    // If validate-only, run post-validation and exit (no indexing)
    if validate_only {
        let report = match magellan::graph::validation::validate_graph(&mut graph) {
            Ok(r) => r,
            Err(e) => {
                tracker.set_error(format!("Validation error: {}", e));
                tracker.finish(&graph)?;
                return ExitCode::from(1);
            }
        };

        if output_format == OutputFormat::Json {
            let response = magellan::output::ValidationResponse {
                passed: report.passed,
                error_count: report.errors.len(),
                errors: report.errors.into_iter().map(|e| magellan::output::ValidationError {
                    code: e.code,
                    message: e.message,
                    entity_id: e.entity_id,
                    details: e.details,
                }).collect(),
                warning_count: report.warnings.len(),
                warnings: report.warnings.into_iter().map(|w| magellan::output::ValidationWarning {
                    code: w.code,
                    message: w.message,
                    entity_id: w.entity_id,
                    details: w.details,
                }).collect(),
            };
            let json_response = magellan::output::JsonResponse::new(response, tracker.exec_id());
            magellan::output::output_json(&json_response)?;
        } else {
            if report.passed {
                println!("Validation passed: no errors found");
            } else {
                eprintln!("Validation failed: {} errors", report.errors.len());
                for error in &report.errors {
                    eprintln!("  [{}] {}", error.code, error.message);
                }
            }
            if !report.warnings.is_empty() {
                eprintln!("Warnings: {}", report.warnings.len());
                for warning in &report.warnings {
                    eprintln!("  [{}] {}", warning.code, warning.message);
                }
            }
        }

        tracker.finish(&graph)?;
        return if report.passed { ExitCode::SUCCESS } else { ExitCode::from(1) };
    }
    ```

    2. After indexing completes (before tracker.finish()), add post-run validation:

    ```rust
    // Post-run validation if enabled
    if validate {
        let report = match magellan::graph::validation::validate_graph(&mut graph) {
            Ok(r) => r,
            Err(e) => {
                tracker.set_error(format!("Post-validation error: {}", e));
                tracker.finish(&graph)?;
                return ExitCode::from(1);
            }
        };

        if !report.passed {
            tracker.set_error(format!("Post-validation failed: {} errors", report.errors.len()));

            if output_format == OutputFormat::Json {
                let response = magellan::output::ValidationResponse {
                    passed: report.passed,
                    error_count: report.errors.len(),
                    errors: report.errors.into_iter().map(|e| magellan::output::ValidationError {
                        code: e.code,
                        message: e.message,
                        entity_id: e.entity_id,
                        details: e.details,
                    }).collect(),
                    warning_count: report.warnings.len(),
                    warnings: report.warnings.into_iter().map(|w| magellan::output::ValidationWarning {
                        code: w.code,
                        message: w.message,
                        entity_id: w.entity_id,
                        details: w.details,
                    }).collect(),
                };
                let json_response = magellan::output::JsonResponse::new(response, tracker.exec_id());
                magellan::output::output_json(&json_response)?;
            } else {
                eprintln!("Validation failed: {} errors", report.errors.len());
                for error in &report.errors {
                    eprintln!("  [{}] {}", error.code, error.message);
                }
            }

            tracker.finish(&graph)?;
            return ExitCode::from(1);
        }

        // Validation passed - optionally show warnings
        if !report.warnings.is_empty() && output_format == OutputFormat::Human {
            eprintln!("Validation passed with {} warnings", report.warnings.len());
        }
    }
    ```

    Place post-run validation after indexing completes but before tracker.finish().
  </action>
  <verify>
    cargo build 2>&1
  </verify>
  <done>
    --validate-only runs post-validation without indexing.
    --validate runs post-validation after indexing completes.
    Validation failures output JSON in JSON mode and exit with code 1.
    Validation results include execution_id via JsonResponse wrapper.
  </done>
</task>

</tasks>

<verification>
1. cargo build passes with no errors
2. --validate flag is accepted by index command
3. --validate-only flag is accepted by index command
4. Pre-run validation executes before indexing
5. Post-run validation executes after indexing
6. Validation failures exit with code 1
7. JSON mode outputs ValidationResponse with execution_id
</verification>

<success_criteria>
- CLI accepts --validate and --validate-only flags
- Pre-run validation checks database and paths before indexing
- --validate-only runs validation without indexing
- --validate runs validation after indexing
- Validation failures exit non-zero with structured output
- All validation output includes execution_id
</success_criteria>

<output>
After completion, create `.planning/phases/08-validation-hooks/08-03-SUMMARY.md`
</output>
