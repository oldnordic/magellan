---
phase: 03-cli-output-contract
plan: 03
type: execute
wave: 3
depends_on: [03-02]
files_modified: [src/output/command.rs, src/query_cmd.rs, src/find_cmd.rs, src/refs_cmd.rs, src/main.rs]
autonomous: true

must_haves:
  truths:
    - "query command has JSON output with Span-aware results"
    - "find command has JSON output with deterministic ordering"
    - "refs command has JSON output with ReferenceMatch types"
    - "files command has JSON output with sorted file list"
    - "All commands use consistent JsonResponse wrapper"
  artifacts:
    - path: "src/output/command.rs"
      provides: "Span, SymbolMatch, ReferenceMatch, FilesResponse types"
      min_lines: 100
    - path: "src/query_cmd.rs"
      provides: "run_query with JSON mode support"
      contains: "OutputFormat"
    - path: "src/find_cmd.rs"
      provides: "run_find with JSON mode support"
      contains: "OutputFormat"
  key_links:
    - from: "src/query_cmd.rs"
      to: "src/output/command.rs"
      via: "Span, SymbolMatch types"
      pattern: "use magellan::output::command::"
    - from: "src/main.rs"
      to: "src/query_cmd.rs"
      via: "output_format parameter passing"
      pattern: "run_query.*output_format"
---

<objective>
Add JSON output to query/find/refs/files commands

Purpose: Complete the JSON output contract for all core query commands. These commands return span-aware results with stable IDs, enabling downstream tooling to parse symbol locations, reference counts, and file listings deterministically.

Output: All query commands support --output json with schema-versioned responses, span-aware matches, and deterministic ordering.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-output-contract/03-RESEARCH.md

# Prior plan outputs
@.planning/phases/03-cli-output-contract/03-01-SUMMARY.md
@.planning/phases/03-cli-output-contract/03-02-SUMMARY.md

# Commands to modify
@src/query_cmd.rs  # query command
@src/find_cmd.rs  # find command
@src/refs_cmd.rs  # refs command
@src/main.rs  # files command, CLI entry point
@src/output/command.rs  # response types to extend
@src/ingest/mod.rs  # SymbolFact span fields reference
</context>

<tasks>

<task type="auto">
  <name>Create span-aware response types (Span, SymbolMatch, ReferenceMatch)</name>
  <files>src/output/command.rs</files>
  <action>
    Add to src/output/command.rs:
    1. Span struct with span_id, file_path, byte_start, byte_end, start_line, start_col, end_line, end_col
    2. SymbolMatch struct with match_id, span, name, kind, parent (Option)
    3. ReferenceMatch struct with match_id, span, referenced_symbol, reference_kind
    4. FilesResponse struct with files: Vec<String>
    5. All derive Serialize, Deserialize

    Follow research Pattern 2 exactly:
    - Span represents half-open range [start, end)
    - span_id is hash-based (can use placeholder for now, proper generation in Phase 4)
    - byte_end is exclusive (first byte NOT included)

    For now, span_id can be format!("{}:{}:{}", file_path, byte_start, byte_end) hash or placeholder.
    Phase 4 will implement proper stable span_id generation per ID-01.

    Match IDs: use hash-based format similar to execution_id for uniqueness.
  </action>
  <verify>Span and SymbolMatch types serialize to JSON with all required fields</verify>
  <done>Span, SymbolMatch, ReferenceMatch, FilesResponse types exist</done>
</task>

<task type="auto">
  <name>Add JSON output to query command</name>
  <files>src/query_cmd.rs</files>
  <action>
    Modify src/query_cmd.rs:
    1. Add output_format: OutputFormat parameter to run_query
    2. In Json mode:
       - Convert SymbolFact results to SymbolMatch with Span
       - Generate match_id for each result
       - Return JsonResponse<QueryResponse> with symbols: Vec<SymbolMatch>
       - Output to stdout via output_json
    3. In Human mode: keep existing behavior

    QueryResponse struct (add to command.rs):
    - symbols: Vec<SymbolMatch>
    - file_path: String
    - kind_filter: Option<String>

    Span mapping from SymbolFact:
    - file_path: symbol.file_path
    - byte_start/end: from symbol
    - start_line/end_line, start_col/end_col: from symbol
    - span_id: placeholder for now (Phase 4)

    Sort results deterministically: by file_path, start_line, start_col, name.
  </action>
  <verify>magellan query --db test.db --file src/lib.rs --output json returns valid JSON with symbols array</verify>
  <done>query --output json returns JsonResponse with SymbolMatch results</done>
</task>

<task type="auto">
  <name>Add JSON output to find command</name>
  <files>src/find_cmd.rs</files>
  <action>
    Modify src/find_cmd.rs:
    1. Add output_format: OutputFormat parameter to run_find
    2. In Json mode:
       - Convert FoundSymbol results to SymbolMatch with Span
       - Return JsonResponse<FindResponse> with matches: Vec<SymbolMatch>
    3. In Human mode: keep existing behavior

    FindResponse struct (add to command.rs):
    - matches: Vec<SymbolMatch>
    - query_name: String
    - file_filter: Option<String>

    For multiple matches, sort by: file_path, start_line, start_col.
    Include node_id in match_id or as separate field for debugging.
  </action>
  <verify>magellan find --db test.db --name main --output json returns JSON with matches array</verify>
  <done>find --output json returns JsonResponse with SymbolMatch results</done>
</task>

<task type="auto">
  <name>Add JSON output to refs command</name>
  <files>src/refs_cmd.rs</files>
  <action>
    First read src/refs_cmd.rs to understand current output format.
    Then modify to add JSON mode:

    1. Add output_format: OutputFormat parameter to run_refs
    2. Create RefsResponse in command.rs:
       - references: Vec<ReferenceMatch>
       - symbol_name: String
       - file_path: String
       - direction: String
    3. In Json mode: convert ReferenceFact to ReferenceMatch, return JsonResponse
    4. In Human mode: keep existing behavior

    ReferenceMatch structure:
    - match_id: String
    - span: Span (from reference)
    - referenced_symbol: String
    - reference_kind: Option<String>

    Sort deterministically by file_path, byte_start.
  </action>
  <verify>magellan refs --db test.db --name main --path src/lib.rs --output json returns JSON</verify>
  <done>refs --output json returns JsonResponse with ReferenceMatch results</done>
</task>

<task type="auto">
  <name>Add JSON output to files command</name>
  <files>src/main.rs</files>
  <action>
    Modify run_files in src/main.rs:
    1. Add output_format: OutputFormat parameter
    2. In Json mode:
       - Collect file paths into Vec<String>, sort
       - Return JsonResponse<FilesResponse>
       - Output via output_json
    3. In Human mode: keep existing behavior

    FilesResponse already created in task 1:
    - files: Vec<String> (sorted)

    Ensure deterministic ordering: sort paths lexicographically.
  </action>
  <verify>magellan files --db test.db --output json returns JSON with sorted files array</verify>
  <done>files --output json returns JsonResponse with sorted file paths</done>
</task>

<task type="auto">
  <name>Update CLI main to pass output_format to all commands</name>
  <files>src/main.rs</files>
  <action>
    Modify src/main.rs:
    1. Update Command::Query variant to include output_format or pass separately
    2. Update Command::Find variant to include output_format or pass separately
    3. Update Command::Refs variant to include output_format or pass separately
    4. Update Command::Files variant to include output_format or pass separately
    5. Pass output_format to each run_* function call in main()

    Implementation: Since --output is a global flag, parse it once in main()
    and pass to all command runners.

    Pattern:
    ```rust
    let output_format = parse_output_format(&args)?;
    match command {
        Command::Query { ... } => run_query(..., output_format),
        ...
    }
    ```
  </action>
  <verify>All commands accept --output flag and produce JSON in JSON mode</verify>
  <done>All query commands support --output json with proper response types</done>
</task>

</tasks>

<verification>
- cargo check --workspace passes
- cargo test --workspace passes
- All query commands work with --output json
- JSON output is deterministic (same input = same output except execution_id, match_ids)
- jq . can parse all command outputs
- Human mode unchanged for all commands
</verification>

<success_criteria>
1. query/find/refs/files commands all support --output json
2. All JSON responses include schema_version and execution_id
3. Span information included in symbol/reference results
4. Output is deterministically ordered
5. Human mode unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-output-contract/03-03-SUMMARY.md`
</output>
