---
phase: 03-cli-output-contract
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [src/main.rs, src/output/command.rs, src/output/mod.rs]
autonomous: true

must_haves:
  truths:
    - "CLI --output json flag works for status command"
    - "status --output json returns JsonResponse<StatusResponse> with schema_version"
    - "status --output json has deterministic ordering (same input = same JSON)"
    - "stdout contains only JSON in JSON mode; stderr gets diagnostics"
  artifacts:
    - path: "src/output/command.rs"
      provides: "StatusResponse, ErrorResponse types for CLI output"
      min_lines: 40
    - path: "src/main.rs"
      provides: "CLI --output flag parsing and format switching"
      contains: "--output"
  key_links:
    - from: "src/main.rs"
      to: "src/output/mod.rs"
      via: "OutputFormat enum use"
      pattern: "use magellan::output::OutputFormat"
    - from: "src/main.rs"
      to: "src/main.rs run_status"
      via: "format parameter"
      pattern: "run_status.*OutputFormat"
---

<objective>
Add CLI --output flag and JSON output for status command (proof of concept)

Purpose: Integrate the output module into the CLI, add --output flag parsing, and implement JSON output for the status command as the first command to get full JSON contract treatment. This validates the pattern before applying to other commands.

Output: Working --output json flag on status command with JsonResponse wrapper, StatusResponse type, and stdout/stderr discipline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-output-contract/03-RESEARCH.md

# Prior plan output
@.planning/phases/03-cli-output-contract/03-01-SUMMARY.md

# CLI to modify
@src/main.rs  # parse_args, Command enum, run_status function
@src/output/mod.rs  # OutputFormat from prior plan
@src/output/json.rs  # JsonResponse from prior plan
@src/graph/mod.rs  # count_* functions for status data
</context>

<tasks>

<task type="auto">
  <name>Create command response types (StatusResponse, ErrorResponse)</name>
  <files>src/output/command.rs</files>
  <action>
    Create src/output/command.rs with:
    1. StatusResponse struct: files, symbols, references, calls, code_chunks (all usize)
    2. ErrorResponse struct: error, message (both String)
    3. Both derive Serialize, Deserialize

    Use BTreeMap for any extra fields to ensure deterministic ordering.

    StatusResponse maps to existing run_status output:
    - files: file count
    - symbols: symbol count
    - references: reference count
    - code_chunks: chunk count

    ErrorResponse is for error responses in JSON mode (e.g., file not found).
  </action>
  <verify>serde_json::to_string(&StatusResponse{...}) produces valid JSON</verify>
  <done>StatusResponse and ErrorResponse types exist and serialize to JSON</done>
</task>

<task type="auto">
  <name>Add --output flag to CLI argument parser</name>
  <files>src/main.rs</files>
  <action>
    Modify src/main.rs:
    1. Add global --output flag to parse_args (accepts "human" or "json", default "human")
    2. Add OutputFormat field to Command enum variants OR use separate global parameter
    3. Approach: Add output_format: OutputFormat field to main() and pass to each run_* function

    Design decision: --output is a global flag, not per-command.
    Parse before command dispatch, pass to each command runner.

    Add to usage text:
    ```
    Global arguments:
      --output <FORMAT>   Output format: human (default) or json
    ```

    Implementation:
    - In parse_args(), detect --output before command parsing
    - Return (Command, OutputFormat) tuple or add OutputFormat to main() directly
    - Default: OutputFormat::Human
  </action>
  <verify>magellan --help shows --output flag; parse_args handles --output json</verify>
  <done>--output flag is recognized and parsed; defaults to human</done>
</task>

<task type="auto">
  <name>Implement JSON output for status command</name>
  <files>src/main.rs</files>
  <action>
    Modify run_status in src/main.rs:
    1. Add output_format: OutputFormat parameter
    2. In Human mode: keep existing println! behavior
    3. In Json mode:
       - Generate execution_id via generate_execution_id()
       - Build StatusResponse from count results
       - Wrap in JsonResponse::new(response, execution_id)
       - Output via output_json() to stdout
       - Any errors go to stderr via log_error()

    Pattern:
    ```rust
    match output_format {
        OutputFormat::Human => {
            println!("files: {}", file_count);
            // ... existing output
        }
        OutputFormat::Json => {
            let response = StatusResponse { files: file_count, ... };
            let wrapped = JsonResponse::new(response, &execution_id);
            output_json(&wrapped)?;
        }
    }
    ```

    Ensure JSON mode has NO progress output to stdout (only the final JSON).
  </action>
  <verify>magellan status --db test.db --output json returns valid JSON with schema_version field</verify>
  <done>status --output json returns JsonResponse<StatusResponse>; human mode unchanged</done>
</task>

<task type="auto">
  <name>Add deterministic ordering tests for status JSON output</name>
  <files>tests/output_tests.rs</files>
  <action>
    Create tests/output_tests.rs with:
    1. test_status_json_output: Verify JSON structure
    2. test_status_deterministic_ordering: Run status --output json twice on same DB, compare byte-for-byte
    3. test_status_schema_version: Verify schema_version field present
    4. test_execution_id_unique: Verify two runs have different execution_ids

    Use existing test database setup patterns from tests/.

    Key test: Same DB queried twice should produce byte-identical JSON EXCEPT for execution_id field.
    The rest of the JSON must be deterministic (field order, values).
  </action>
  <verify>cargo test output_tests passes; deterministic test passes</verify>
  <done>JSON output is deterministic across runs (except execution_id)</done>
</task>

</tasks>

<verification>
- cargo check --workspace passes
- cargo test --workspace passes
- magellan status --output json returns valid JSON
- jq . can parse the output
- Running twice on same DB produces identical JSON (except execution_id)
</verification>

<success_criteria>
1. --output json flag works on status command
2. Status JSON includes schema_version and execution_id
3. JSON output is deterministic (same input = same byte output except execution_id)
4. stdout contains only JSON; stderr gets errors
5. Human mode unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-output-contract/03-02-SUMMARY.md`
</output>
