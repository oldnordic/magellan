---
phase: 03-cli-output-contract
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib.rs, src/output/mod.rs, src/output/json.rs, src/output/execution.rs, src/ingest/mod.rs]
autonomous: true

must_haves:
  truths:
    - "output module exists and compiles"
    - "JsonResponse wrapper includes schema_version and execution_id fields"
    - "execution_id generation is deterministic for same inputs"
    - "stdout/stderr helper macros output to correct streams"
  artifacts:
    - path: "src/output/mod.rs"
      provides: "OutputFormat enum and module exports"
      min_lines: 20
    - path: "src/output/json.rs"
      provides: "JsonResponse wrapper with schema_version"
      min_lines: 50
    - path: "src/output/execution.rs"
      provides: "generate_execution_id function"
      min_lines: 30
    - path: "src/ingest/mod.rs"
      provides: "SymbolFact with serde derive (may already exist)"
      contains: "Serialize, Deserialize"
  key_links:
    - from: "src/lib.rs"
      to: "src/output/mod.rs"
      via: "pub mod output declaration"
      pattern: "pub mod output"
    - from: "src/output/json.rs"
      to: "src/output/execution.rs"
      via: "generate_execution_id import"
      pattern: "use.*generate_execution_id"
---

<objective>
Build the output module foundation for JSON contract

Purpose: Establish the core types and infrastructure for schema-versioned JSON output, stable execution IDs, and stdout/stderr discipline that all commands will use in Phase 3.

Output: New `src/output/` module with `OutputFormat` enum, `JsonResponse<T>` wrapper, execution ID generation, and stdout/stderr helper macros.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-output-contract/03-RESEARCH.md

# Existing types to reference
@src/ingest/mod.rs  # SymbolFact span fields for consistent Span type
@src/diagnostics/watch_diagnostics.rs  # WatchDiagnostic serde pattern
@src/graph/export.rs  # GraphExport deterministic sorting pattern
@src/lib.rs  # Public API exports
</context>

<tasks>

<task type="auto">
  <name>Create output module structure with OutputFormat enum</name>
  <files>src/output/mod.rs</files>
  <action>
    Create src/output/mod.rs with:
    1. pub mod json, mod execution declarations
    2. OutputFormat enum { Human, Json } with serde Serialize/Deserialize
    3. Re-exports: JsonResponse, generate_execution_id, output_json, log_error, log_warning, log_info

    Pattern from research:
    - Use serde 1.0 (already in repo)
    - Keep enum simple for CLI flag parsing
    - Derive Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize
  </action>
  <verify>cargo check passes; OutputFormat::Json.serialized() produces "Json"</verify>
  <done>OutputFormat enum exists with Human and Json variants; module compiles</done>
</task>

<task type="auto">
  <name>Implement JsonResponse wrapper with schema_version</name>
  <files>src/output/json.rs</files>
  <action>
    Create src/output/json.rs with:
    1. MAGELLAN_JSON_SCHEMA_VERSION const = "1.0.0"
    2. JsonResponse<T> struct with schema_version, execution_id, data, partial fields
    3. json_response<T>(data, execution_id) constructor
    4. impl Serialize/Deserialize for JsonResponse where T: Serialize/Deserialize

    Follow research Pattern 1 exactly:
    - schema_version: String (always present)
    - execution_id: String (stable per run)
    - data: T (actual response payload)
    - partial: Option<bool> (skip if None via skip_serializing_if)
  </action>
  <verify>serde_json::to_string(&json_response("test", "exec-123")) produces valid JSON with all fields</verify>
  <done>JsonResponse<T> serializes to JSON with schema_version, execution_id, data fields</done>
</task>

<task type="auto">
  <name>Implement deterministic execution_id generation</name>
  <files>src/output/execution.rs</files>
  <action>
    Create src/output/execution.rs with:
    1. generate_execution_id() -> String function
    2. Use hash-based approach per research recommendation: format!("{:x}", now.timestamp())[..16] + pid hex
    3. Or simpler: SHA256 hash of (timestamp + pid + maybe db_path), first 16 hex chars
    4. Add tests verifying determinism for same inputs

    Research decision: Use hash-based for simplicity (no uuid crate dependency):
    - Input: UNIX timestamp (secs) + process ID + random component
    - Format: 16-character hex string (first 8 chars of timestamp, 8 chars of pid/random)
    - NOT guaranteed globally unique (good enough for v1)

    Use std::time::SystemTime and std::process::id() for inputs.
  </action>
  <verify>generate_execution_id() returns 16+ char hex string; multiple calls return different values</verify>
  <done>generate_execution_id returns unique hex string; added tests for uniqueness</done>
</task>

<task type="auto">
  <name>Implement stdout/stderr helper macros and output_json function</name>
  <files>src/output/mod.rs</files>
  <action>
    Add to src/output/mod.rs:
    1. output_json<T: Serialize>(data: &T) -> Result<()> function using serde_json::to_string_pretty
    2. log_error(msg: &str), log_warning(msg: &str), log_info(msg: &str) using eprintln!
    3. Macro versions: out_json!, err_log! for inline use

    Follow research Pattern 4:
    - stdout = JSON data only (println!)
    - stderr = logs/diagnostics (eprintln!)
    - Use to_string_pretty for human-readable JSON in human mode

    Note: Phase 3 is about JSON contract, not improving human output. Keep human mode unchanged.
  </action>
  <verify>output_json(&test_data) prints to stdout; log_error("test") prints to stderr</verify>
  <done>stdout/stderr helpers output to correct streams; macros work inline</done>
</task>

<task type="auto">
  <name>Verify existing types have serde derives</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Check src/ingest/mod.rs for SymbolFact serde derive. If missing, add Serialize, Deserialize.
    Verify SymbolFact has span fields: byte_start, byte_end, start_line, start_col, end_line, end_col.

    Research confirms SymbolFact already has span fields. Verify serde exists for JSON output.
    If serde is missing on SymbolFact, add #[derive(Serialize, Deserialize)].

    Also check ReferenceFact, CallFact in src/references.rs for serde.
  </action>
  <verify>SymbolFact, ReferenceFact, CallFact all have Serialize/Deserialize derives</verify>
  <done>Core fact types are serde-serializable for JSON output</done>
</task>

<task type="auto">
  <name>Export output module from lib.rs</name>
  <files>src/lib.rs</files>
  <action>
    Add to src/lib.rs:
    1. pub mod output;
    2. Re-export OutputFormat, JsonResponse, generate_execution_id

    Keep existing exports unchanged. Add new exports after existing ones.
  </action>
  <verify>cargo check passes; use magellan::OutputFormat works from other crates</verify>
  <done>output module is publicly accessible from magellan crate</done>
</task>

</tasks>

<verification>
- cargo check --workspace passes
- cargo test --workspace passes
- Manual test: generate_execution_id returns unique values
- serde_json::to_string produces valid JSON for JsonResponse
</verification>

<success_criteria>
1. output module compiles with OutputFormat, JsonResponse, execution ID generation
2. JsonResponse wrapper includes schema_version and execution_id fields
3. Core types (SymbolFact, ReferenceFact, CallFact) are serde-serializable
4. stdout/stderr helpers output to correct streams
5. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-output-contract/03-01-SUMMARY.md`
</output>
