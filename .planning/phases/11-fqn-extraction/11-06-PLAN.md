---
phase: 11-fqn-extraction
plan: 06
type: execute
wave: 5
depends_on: [11-02, 11-03, 11-04, 11-05]
files_modified:
  - src/graph/symbols.rs
  - src/graph/ops.rs
  - src/graph/query.rs
  - tests/fqn_integration_tests.rs
  - src/db.rs
autonomous: true

must_haves:
  truths:
    - "symbol_id generation uses hash(language, FQN, span_id)"
    - "SymbolFact.fqn field is populated during extraction"
    - "Full re-index produces correct FQNs throughout the graph"
    - "Integration tests verify FQN correctness for multi-file codebase"
    - "Old databases are rejected with helpful migration message"
  artifacts:
    - path: "src/graph/symbols.rs"
      contains: "insert_symbol_node"
      pattern: "fact\\.fqn"
    - path: "tests/fqn_integration_tests.rs"
      provides: "Integration tests for FQN extraction"
      min_lines: 150
    - path: "src/graph/symbols.rs"
      contains: "generate_symbol_id"
    - path: "src/db.rs"
      contains: "DATABASE_VERSION"
  key_links:
    - from: "insert_symbol_node"
      to: "SymbolNode"
      via: "fqn field populated from fact.fqn"
      pattern: "fqn: fact\\.fqn"
    - from: "generate_symbol_id"
      to: "hash input"
      via: "fqn parameter used in hash"
      pattern: "hasher\\.update\\(fqn"
    - from: "CodeGraph::open"
      to: "database version check"
      via: "rejects old databases with migration message"
      pattern: "DATABASE_VERSION"
---

<objective>
Complete the FQN implementation by ensuring symbol_id generation uses the proper FQN (not simple name), SymbolFact stores FQN, and integration tests verify end-to-end correctness. Handle the breaking change by bumping the database version and rejecting old databases with a helpful migration message.

Purpose: The symbol_id is the stable identifier used throughout the graph. It must be derived from the FQN to prevent collisions. This plan also adds integration tests and handles the database migration (forced re-index) via version bump.

Output:
- symbol_id generation explicitly uses fact.fqn
- SymbolFact.fqn populated in all parsers
- Integration tests covering multi-file FQN scenarios
- Database version bump with helpful error message for old databases
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/11-fqn-extraction/11-CONTEXT.md
@.planning/phases/11-fqn-extraction/11-02-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-03-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-04-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-05-SUMMARY.md
@src/graph/symbols.rs
@src/graph/ops.rs
@src/graph/query.rs
@src/db.rs
</context>

<tasks>

<task type="auto">
  <name>Verify symbol_id generation uses FQN correctly</name>
  <files>src/graph/symbols.rs</files>
  <action>
    Review and verify insert_symbol_node uses FQN:

    The current code (line 150-156) is:
    ```rust
    // Get FQN for symbol_id generation
    // Use name as fallback if fqn is not set (v1 compatibility)
    let name_for_fqn = fact.name.as_deref().unwrap_or("");
    let fqn = fact.fqn.as_deref().unwrap_or(name_for_fqn);

    // Generate stable symbol_id
    let symbol_id = generate_symbol_id(&language, fqn, &span_id);
    ```

    This is already correct - it prefers fact.fqn over name.

    Add a comment clarifying this is intentional:
    ```rust
    // Generate stable symbol_id from (language, FQN, span_id)
    // FQN prevents collisions; span_id ensures uniqueness within FQN
    let fqn_for_id = fact.fqn.as_deref().unwrap_or("");
    let symbol_id = generate_symbol_id(&language, fqn_for_id, &span_id);
    ```

    Also ensure SymbolNode stores the FQN:
    ```rust
    let symbol_node = SymbolNode {
        symbol_id: Some(symbol_id),
        fqn: fact.fqn.clone(),  // Store FQN for lookup
        name: fact.name.clone(), // Keep name for display
        // ... rest of fields
    };
    ```

    No algorithm changes - just verification and documentation.
  </action>
  <verify>
    cargo test --package magellan symbols::tests passes
    All symbol_id tests use FQN
  </verify>
  <done>symbol_id generation verified to use FQN</done>
</task>

<task type="auto">
  <name>Create comprehensive FQN integration tests</name>
  <files>tests/fqn_integration_tests.rs</files>
  <action>
    Create new test file with end-to-end FQN verification:

    ```rust
    //! Integration tests for fully-qualified name extraction
    //!
    //! Verifies that FQNs are correctly built and used for symbol lookup
    //! across multiple files and languages.

    use magellan::CodeGraph;
    use tempfile::TempDir;

    #[test]
    fn test_rust_fqn_multi_file() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.db");
        let mut graph = CodeGraph::open(&db_path).unwrap();

        // Create a multi-file Rust project
        let mod_rs = br#"
mod utils;

pub fn main() {
    utils::helper();
}
"#;

        let utils_rs = br#"
pub fn helper() {}

pub struct MyStruct;

impl MyStruct {
    pub fn method(&self) {}
}
"#;

        graph.index_file("src/mod.rs", mod_rs).unwrap();
        graph.index_file("src/utils.rs", utils_rs).unwrap();

        // Query symbols and verify FQNs
        let symbols = graph.symbols_in_file("src/utils.rs").unwrap();

        // helper should have FQN "utils::helper" or "helper" (top-level in its file)
        let helper: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("helper"))
            .collect();

        assert!(!helper.is_empty(), "Should find helper function");
        // After full FQN implementation, this will be "utils::helper"
        // For now, verify it has some FQN
        assert!(helper[0].fqn.is_some());

        // method should have FQN "MyStruct::method"
        let methods: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("method"))
            .collect();

        assert!(!methods.is_empty(), "Should find method");
        assert_eq!(methods[0].fqn.as_deref(), Some("MyStruct::method"));
    }

    #[test]
    fn test_java_package_fqn() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.db");
        let mut graph = CodeGraph::open(&db_path).unwrap();

        let source = br#"
package com.example.app;

public class Application {
    public void run() {}

    private static class Helper {
        public void help() {}
    }
}
"#;

        graph.index_file("Application.java", source).unwrap();

        let symbols = graph.symbols_in_file("Application.java").unwrap();

        // run method: com.example.app.Application.run
        let run: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("run"))
            .collect();

        assert_eq!(run.len(), 1);
        assert_eq!(run[0].fqn.as_deref(), Some("com.example.app.Application.run"));

        // help method: com.example.app.Application.Helper.help
        let help: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("help"))
            .collect();

        assert_eq!(help.len(), 1);
        // Note: full FQN includes inner class
        assert!(help[0].fqn.as_deref().unwrap().contains("help"));
    }

    #[test]
    fn test_python_class_fqn() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.db");
        let mut graph = CodeGraph::open(&db_path).unwrap();

        let source = br#"
class DataProcessor:
    def process(self):
        pass

    class NestedHelper:
        def help(self):
            pass
"#;

        graph.index_file("processor.py", source).unwrap();

        let symbols = graph.symbols_in_file("processor.py").unwrap();

        // process method: DataProcessor.process
        let process: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("process"))
            .collect();

        assert_eq!(process.len(), 1);
        assert_eq!(process[0].fqn.as_deref(), Some("DataProcessor.process"));

        // help method: DataProcessor.NestedHelper.help
        let help: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("help"))
            .collect();

        assert_eq!(help.len(), 1);
        assert!(help[0].fqn.as_deref().unwrap().contains("NestedHelper.help"));
    }

    #[test]
    fn test_cpp_namespace_fqn() {
        let dir = TempDir::new().unwrap();
        let db_path = dir.path().join("test.db");
        let mut graph = CodeGraph::open(&db_path).unwrap();

        let source = br#"
namespace graphics {
    struct Point {
        int x;
        int y;
    };

    namespace render {
        void draw(const Point& p);
    }
}
"#;

        graph.index_file("graphics.cpp", source).unwrap();

        let symbols = graph.symbols_in_file("graphics.cpp").unwrap();

        // Point: graphics::Point
        let point: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("Point"))
            .collect();

        assert_eq!(point.len(), 1);
        assert_eq!(point[0].fqn.as_deref(), Some("graphics::Point"));

        // draw: graphics::render::draw
        let draw: Vec<_> = symbols.iter()
            .filter(|s| s.name.as_deref() == Some("draw"))
            .collect();

        assert_eq!(draw.len(), 1);
        assert_eq!(draw[0].fqn.as_deref(), Some("graphics::render::draw"));
    }

    #[test]
    fn test_symbol_id_stability_with_fqn() {
        use magellan::graph::generate_symbol_id;

        // Same FQN and span produce same ID
        let id1 = generate_symbol_id("rust", "my_crate::my_module::my_function", "span123");
        let id2 = generate_symbol_id("rust", "my_crate::my_module::my_function", "span123");
        assert_eq!(id1, id2);

        // Different FQN produces different ID
        let id3 = generate_symbol_id("rust", "other_crate::my_function", "span123");
        assert_ne!(id1, id3);

        // Same name, different scope (different FQN) = different ID
        let id4 = generate_symbol_id("rust", "my_crate::other_module::my_function", "span123");
        assert_ne!(id1, id4);
    }
    ```

    Tests verify FQN correctness across all major language patterns.
  </action>
  <verify>
    cargo test --package magellan --test fqn_integration_tests passes
    All 5 tests pass
  </verify>
  <done>Integration tests verify FQN extraction end-to-end</done>
</task>

<task type="auto">
  <name>Update SymbolFact to ensure fqn field is always populated</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Verify SymbolFact.fqn is set in extract_symbol_with_fqn:

    The function should always set fqn:
    ```rust
    let fqn = scope_stack.fqn_for_symbol(&name);

    Some(SymbolFact {
        file_path: file_path.clone(),
        kind: symbol_kind,
        kind_normalized: normalized_kind,
        name: Some(name),
        fqn: Some(fqn),  // Always Some, never None
        // ...
    })
    ```

    Ensure fqn field is never None after extraction. The only case for None would be anonymous symbols (closures), which use parent scope via fqn_for_symbol("").

    Add a test verifying this:
    ```rust
    #[test]
    fn test_fqn_always_populated() {
        let mut parser = Parser::new().unwrap();
        let source = b"pub fn test_fn() {}\n";
        let facts = parser.extract_symbols(PathBuf::from("test.rs"), source);

        assert!(!facts.is_empty());
        assert!(facts[0].fqn.is_some(), "FQN should always be populated");
        assert!(!facts[0].fqn.as_ref().unwrap().is_empty(), "FQN should not be empty");
    }
    ```
  </action>
  <verify>
    cargo test --package magellan ingest passes
    test_fqn_always_populated passes
  </verify>
  <done>SymbolFact.fqn is always populated after extraction</done>
</task>

<task type="auto">
  <name>Bump database version and add helpful migration message</name>
  <files>src/db.rs</files>
  <action>
    FQN changes are a breaking change for symbol_id generation. Bump DATABASE_VERSION and reject old databases with a helpful message.

    1. Check current DATABASE_VERSION in src/db.rs:
    ```bash
        grep -n "DATABASE_VERSION" /home/feanor/Projects/magellan/src/db.rs
    ```

    2. Bump the version (e.g., if current is 1, change to 2):
    ```rust
    pub const DATABASE_VERSION: u32 = 2;  // Bumped for FQN-based symbol_id
    ```

    3. In CodeGraph::open(), check version and return helpful error on mismatch:
    ```rust
    // After opening database connection
    let existing_version: u32 = db.query_row(
        "SELECT value FROM metadata WHERE key = 'database_version'",
        [],
        |row| row.get(0)
    ).unwrap_or(0);

    if existing_version != DATABASE_VERSION {
        return Err(Error::DatabaseVersionMismatch {
            expected: DATABASE_VERSION,
            found: existing_version,
            hint: "FQN implementation changed. Delete the database and re-index your codebase.".to_string()
        });
    }
    ```

    4. Define the error variant in src/error.rs if not exists:
    ```rust
    #[derive(Debug, thiserror::Error)]
    pub enum Error {
        #[error("Database version mismatch: expected {expected}, found {found}")]
        #[error("Hint: {hint}")]
        DatabaseVersionMismatch { expected: u32, found: u32, hint: String },
        // ... other variants
    }
    ```

    This ensures users know to delete and re-index instead of getting corrupted results.
  </action>
  <verify>
    cargo check --all-targets passes
    Error variant compiles
    Database version check compiles
  </verify>
  <done>
    Database version bumped to 2
    Old databases rejected with helpful migration message
  </done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan` - all tests pass including new integration tests
3. Verify symbol_id uses FQN in hash computation
4. Verify SymbolNode stores fqn field
5. Verify all SymbolFact instances have non-empty fqn after extraction
6. Test multi-file scenarios produce correct FQNs
7. Verify database version mismatch returns helpful error message
</verification>

<success_criteria>
1. symbol_id generated from hash(language, FQN, span_id)
2. SymbolFact.fqn always populated (never None for named symbols)
3. SymbolNode.fqn stored in database
4. Integration tests pass for all 8 languages
5. FQN prevents name collisions in lookup
6. Same symbol in different scopes has different symbol_id
7. Old databases rejected with clear re-index instruction
</success_criteria>

<output>
After completion, create `.planning/phases/11-fqn-extraction/11-06-SUMMARY.md`
</output>
