---
phase: 11-fqn-extraction
plan: 05
type: execute
wave: 4
depends_on: [11-02, 11-03, 11-04]
files_modified:
  - src/graph/query.rs
  - src/graph/calls.rs
  - src/graph/references.rs
autonomous: true

must_haves:
  truths:
    - "Symbol lookup maps use FQN as key (not simple name)"
    - "Reference indexing matches by FQN instead of name"
    - "Call indexing matches by FQN instead of name"
    - "FQN collisions are logged at WARN level"
    - "Symbol queries return unique symbols by FQN"
  artifacts:
    - path: "src/graph/query.rs"
      contains: "index_references"
      pattern: "fqn"
    - path: "src/graph/calls.rs"
      contains: "symbol_fqn_to_id"
      pattern: "FQN"
    - path: "src/graph/references.rs"
      contains: "fqn"
      pattern: "symbol_fqn_to_id|fqn"
  key_links:
    - from: "src/graph/query.rs"
      to: "SymbolNode"
      via: "symbol_node.fqn or symbol_node.name as fallback"
      pattern: "symbol_fqn_to_id"
    - from: "src/graph/calls.rs"
      to: "SymbolNode"
      via: "FQN-based lookup"
      pattern: "fqn"
---

<objective>
Update symbol lookup maps in query.rs, calls.rs, and references.rs to use FQN as the key instead of simple symbol names. This eliminates collisions when multiple symbols have the same name in different scopes.

Purpose: The current lookup maps use simple names (HashMap<String, i64>), causing first-match-wins behavior for symbols with identical names. FQN keys eliminate this by providing unique, hierarchical identifiers.

Output:
- symbol_name_to_id renamed to symbol_fqn_to_id throughout
- Maps built from SymbolNode.fqn field (not name)
- FQN collision warnings emitted
- Reference and call indexing use FQN matching
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/11-fqn-extraction/11-CONTEXT.md
@.planning/phases/11-fqn-extraction/11-02-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-03-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-04-SUMMARY.md
@src/graph/query.rs
@src/graph/calls.rs
@src/graph/references.rs
@src/graph/schema.rs
</context>

<tasks>

<task type="auto">
  <name>Update query.rs to use FQN-based symbol lookup</name>
  <files>src/graph/query.rs</files>
  <action>
    Modify index_references function to use FQN as key:

    1. Rename HashMap and change key extraction:
    ```rust
    // Build map: FQN -> node ID from ALL symbols in database
    let mut symbol_fqn_to_id: HashMap<String, i64> = HashMap::new();

    // Get all entity IDs from the graph
    let entity_ids = graph.files.backend.entity_ids()?;

    // Iterate through all entities and find Symbol nodes
    for entity_id in entity_ids {
        if let Ok(node) = graph.files.backend.get_node(entity_id) {
            if node.kind == "Symbol" {
                if let Ok(symbol_node) = serde_json::from_value::<SymbolNode>(node.data) {
                    // Use FQN as key, fall back to name for backward compatibility
                    let fqn = symbol_node
                        .fqn
                        .or(symbol_node.name)
                        .unwrap_or_default();

                    if !fqn.is_empty() {
                        // Check for FQN collisions
                        if let Some(&existing_id) = symbol_fqn_to_id.get(&fqn) {
                            if existing_id != entity_id {
                                eprintln!("WARNING: FQN collision detected for '{}': symbols {} and {} share the same FQN",
                                    fqn, existing_id, entity_id);
                            }
                        } else {
                            symbol_fqn_to_id.insert(fqn, entity_id);
                        }
                    }
                }
            }
        }
    }
    ```

    2. Pass symbol_fqn_to_id to references.index_references()

    FQN collision warnings help users identify problematic code.
  </action>
  <verify>cargo check --all-targets passes (query compiles)</verify>
  <done>query.rs uses FQN as key for symbol lookup</done>
</task>

<task type="auto">
  <name>Update references.rs to accept FQN-based map</name>
  <files>src/graph/references.rs</files>
  <action>
    Modify ReferenceOps to work with FQN-based matching:

    1. Update index_references signature:
    ```rust
    pub fn index_references(
        &self,
        path: &str,
        source: &[u8],
        symbol_fqn_to_id: &HashMap<String, i64>,  // Changed from symbol_name_to_id
    ) -> Result<usize>
    ```

    2. Build all_symbol_facts with FQN:
    ```rust
    // Build symbol_facts from ALL symbols in the database
    let mut all_symbol_facts: Vec<crate::ingest::SymbolFact> = Vec::new();

    for entity_id in entity_ids {
        if let Ok(node) = self.backend.get_node(entity_id) {
            if node.kind == "Symbol" {
                if let Ok(symbol_node) = serde_json::from_value::<SymbolNode>(node.data.clone()) {
                    let file_path_str = node.file_path.as_deref().unwrap_or("");
                    if std::str::from_utf8(file_path_str.as_bytes()).is_ok() {
                        // Extract FQN, fall back to name for backward compatibility
                        let fqn = symbol_node
                            .fqn
                            .clone()
                            .or(symbol_node.name.clone())
                            .unwrap_or_default();

                        all_symbol_facts.push(crate::ingest::SymbolFact {
                            file_path: PathBuf::from(file_path_str),
                            kind: /* existing kind mapping */,
                            kind_normalized: /* existing */,
                            name: symbol_node.name.clone(),
                            fqn: if fqn.is_empty() { None } else { Some(fqn) },
                            /* ... rest of fields ... */
                        });
                    }
                }
            }
        }
    }
    ```

    3. Update reference matching to use FQN when available

    The reference extraction still uses name matching (identifiers in source), but lookup uses FQN.
  </action>
  <verify>cargo check --all-targets passes</verify>
  <done>references.rs updated for FQN-based lookup</done>
</task>

<task type="auto">
  <name>Update calls.rs for FQN-based symbol matching</name>
  <files>src/graph/calls.rs</files>
  <action>
    Modify index_calls function:

    1. Change HashMap name and key extraction:
    ```rust
    pub fn index_calls(graph: &mut CodeGraph, path: &str, source: &[u8]) -> Result<usize> {
        // Build map: FQN -> node ID from ALL symbols in database
        let mut symbol_fqn_to_id: HashMap<String, (i64, bool)> = HashMap::new();
        let entity_ids = graph.files.backend.entity_ids()?;

        for entity_id in entity_ids {
            if let Ok(node) = graph.files.backend.get_node(entity_id) {
                if node.kind != "Symbol" {
                    continue;
                }

                let symbol_node: SymbolNode = match serde_json::from_value(node.data.clone()) {
                    Ok(value) => value,
                    Err(_) => continue,
                };

                // Use FQN as key, fall back to name
                let fqn = symbol_node
                    .fqn
                    .or(symbol_node.name)
                    .unwrap_or_default();

                if !fqn.is_empty() {
                    let is_current_file = node.file_path.as_deref() == Some(path);
                    match symbol_fqn_to_id.get(&fqn) {
                        Some((_, existing_is_current)) if *existing_is_current || !is_current_file => {}
                        _ => {
                            symbol_fqn_to_id.insert(fqn, (entity_id, is_current_file));
                        }
                    }
                }
            }
        }

        let symbol_fqn_to_id: HashMap<String, i64> = symbol_fqn_to_id
            .into_iter()
            .map(|(fqn, (id, _))| (fqn, id))
            .collect();

        graph.calls.index_calls(path, source, &symbol_fqn_to_id)
    }
    ```

    Note: call extraction still uses simple name matching (identifiers in source). The FQN map is for resolving which specific symbol a call refers to when names collide.
  </action>
  <verify>cargo check --all-targets passes</verify>
  <done>calls.rs uses FQN for symbol lookup</done>
</task>

<task type="auto">
  <name>Update SymbolNode schema to include fqn field</name>
  <files>src/graph/schema.rs</files>
  <action>
    Add fqn field to SymbolNode:

    ```rust
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct SymbolNode {
        /// Stable symbol ID derived from (language, fqn, span_id)
        #[serde(default)]
        pub symbol_id: Option<String>,

        /// Fully-qualified name for this symbol
        /// Format varies by language (crate::module::Name for Rust, package.Class.Name for Java)
        /// This is the primary key for symbol lookup, preventing name collisions
        #[serde(default)]
        pub fqn: Option<String>,

        /// Simple symbol name (display name)
        /// For user-facing output only. Not used as a unique identifier.
        pub name: Option<String>,

        pub kind: String,
        #[serde(default)]
        pub kind_normalized: Option<String>,
        pub byte_start: usize,
        pub byte_end: usize,
        pub start_line: usize,
        pub start_col: usize,
        pub end_line: usize,
        pub end_col: usize,
    }
    ```

    This change is backward compatible (new field with default).
  </action>
  <verify>cargo check --all-targets passes (schema compiles)</verify>
  <done>SymbolNode includes fqn field</done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan graph::` - all graph tests pass
3. Verify FQN is used as lookup key in all three modules
4. Verify fallback to name for backward compatibility
5. Verify FQN collision warnings are emitted
</verification>

<success_criteria>
1. query.rs builds symbol_fqn_to_id map (not symbol_name_to_id)
2. references.rs accepts FQN-based HashMap
3. calls.rs uses FQN for symbol resolution
4. SymbolNode schema has fqn field
5. FQN collision warnings emitted to stderr
6. All graph tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-fqn-extraction/11-05-SUMMARY.md`
</output>
