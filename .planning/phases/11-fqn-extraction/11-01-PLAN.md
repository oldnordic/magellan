---
phase: 11-fqn-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ingest/mod.rs
autonomous: true

must_haves:
  truths:
    - "ScopeStack struct tracks module and type scope during tree traversal"
    - "ScopeStack can push/pop scope levels with proper separators (:: for Rust, . for others)"
    - "ScopeStack current_fqn() returns the fully-qualified name at current depth"
    - "Anonymous symbols (closures, impl blocks) use parent scope"
  artifacts:
    - path: "src/ingest/mod.rs"
      provides: "ScopeStack struct for FQN tracking"
      exports: ["ScopeStack", "ScopeSeparator"]
      min_lines: 80
    - path: "src/ingest/mod.rs"
      contains: "pub struct ScopeStack"
    - path: "src/ingest/mod.rs"
      contains: "impl ScopeStack"
      exports: ["new", "push", "pop", "current_fqn", "separator"]
  key_links:
    - from: "ScopeStack"
      to: "language-specific parsers"
      via: "use crate::ingest::ScopeStack"
      pattern: "ScopeStack"
---

<objective>
Create the ScopeStack infrastructure for tracking semantic scope during tree-sitter traversal. This is the foundation for building fully-qualified names (FQNs) across all language parsers.

Purpose: FQNs eliminate symbol name collisions by providing a complete hierarchical path (e.g., `crate::module::Struct::method` instead of just `method`). The ScopeStack provides a reusable mechanism for all 8 language parsers to track scope nesting.

Output:
- ScopeStack struct in src/ingest/mod.rs with push/pop operations
- ScopeSeparator enum for language-specific separators (:: vs .)
- Comprehensive unit tests covering push/pop, nesting, anonymous symbols
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-fqn-extraction/11-CONTEXT.md
@src/ingest/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Define ScopeSeparator enum and ScopeStack struct</name>
  <files>src/ingest/mod.rs</files>
  <action>
    After the SymbolKind enum (around line 45), add:

    ```rust
    /// Separator character for FQN construction per language
    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum ScopeSeparator {
        /// Rust, C, C++ use :: separator
        DoubleColon,
        /// Python, Java, JavaScript, TypeScript use . separator
        Dot,
    }

    impl ScopeSeparator {
        pub fn as_str(&self) -> &'static str {
            match self {
                ScopeSeparator::DoubleColon => "::",
                ScopeSeparator::Dot => ".",
            }
        }
    }

    /// Stack for tracking scope nesting during tree-sitter traversal
    ///
    /// Maintains a hierarchy of scope names (modules, types, namespaces)
    /// to build fully-qualified names for symbols.
    ///
    /// # Example
    /// ```rust
    /// let mut stack = ScopeStack::new(ScopeSeparator::DoubleColon);
    /// stack.push("my_crate");
    /// stack.push("my_module");
    /// assert_eq!(stack.current_fqn(), "my_crate::my_module");
    /// stack.push("MyStruct");
    /// assert_eq!(stack.current_fqn(), "my_crate::my_module::MyStruct");
    /// ```
    #[derive(Debug, Clone)]
    pub struct ScopeStack {
        /// Scope components in order (e.g., ["my_crate", "my_module", "MyStruct"])
        scopes: Vec<String>,
        /// Separator for this language
        separator: ScopeSeparator,
    }
    ```

    Keep the module clean - this is foundational infrastructure.
  </action>
  <verify>cargo check --all-targets passes (new types compile)</verify>
  <done>ScopeSeparator and ScopeStack struct definitions added</done>
</task>

<task type="auto">
  <name>Implement ScopeStack methods with push/pop/fqn operations</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Add impl block for ScopeStack:

    ```rust
    impl ScopeStack {
        /// Create a new empty scope stack
        pub fn new(separator: ScopeSeparator) -> Self {
            Self {
                scopes: Vec::new(),
                separator,
            }
        }

        /// Push a new scope level onto the stack
        ///
        /// Used when entering a module, class, namespace, or other semantic scope.
        pub fn push(&mut self, scope: impl Into<String>) {
            self.scopes.push(scope.into());
        }

        /// Pop the most recent scope level from the stack
        ///
        /// Used when exiting a module, class, or namespace.
        /// Returns the popped scope name, or None if stack was empty.
        pub fn pop(&mut self) -> Option<String> {
            if self.scopes.is_empty() {
                None
            } else {
                Some(self.scopes.pop().unwrap())
            }
        }

        /// Get the current fully-qualified name
        ///
        /// Returns empty string if stack is empty (top-level symbols).
        /// Otherwise returns components joined by separator.
        pub fn current_fqn(&self) -> String {
            if self.scopes.is_empty() {
                String::new()
            } else {
                let sep = self.separator.as_str();
                self.scopes.join(sep)
            }
        }

        /// Get FQN for a symbol within the current scope
        ///
        /// If symbol_name is provided, appends it to current scope.
        /// If no current scope, returns symbol_name only.
        /// If symbol_name is empty and no scope, returns empty (for anonymous symbols).
        pub fn fqn_for_symbol(&self, symbol_name: &str) -> String {
            let current = self.current_fqn();
            if current.is_empty() {
                symbol_name.to_string()
            } else if symbol_name.is_empty() {
                current
            } else {
                format!("{}{}{}", current, self.separator.as_str(), symbol_name)
            }
        }

        /// Get the depth of the scope stack
        pub fn depth(&self) -> usize {
            self.scopes.len()
        }

        /// Check if stack is empty
        pub fn is_empty(&self) -> bool {
            self.scopes.is_empty()
        }

        /// Get the separator for this stack
        pub fn separator(&self) -> ScopeSeparator {
            self.separator
        }
    }
    ```

    Include comprehensive documentation - this is used by all language parsers.
  </action>
  <verify>cargo check --all-targets passes (all methods compile)</verify>
  <done>ScopeStack fully implemented with push/pop/fqn operations</done>
</task>

<task type="auto">
  <name>Add ScopeStack unit tests</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Add #[cfg(test)] tests after the Parser impl block:

    ```rust
    #[cfg(test)]
    mod scope_stack_tests {
        use super::*;

        #[test]
        fn test_empty_stack() {
            let stack = ScopeStack::new(ScopeSeparator::DoubleColon);
            assert_eq!(stack.current_fqn(), "");
            assert!(stack.is_empty());
            assert_eq!(stack.depth(), 0);
        }

        #[test]
        fn test_push_single_scope() {
            let mut stack = ScopeStack::new(ScopeSeparator::DoubleColon);
            stack.push("my_crate");
            assert_eq!(stack.current_fqn(), "my_crate");
            assert_eq!(stack.depth(), 1);
        }

        #[test]
        fn test_push_multiple_scopes() {
            let mut stack = ScopeStack::new(ScopeSeparator::DoubleColon);
            stack.push("my_crate");
            stack.push("my_module");
            stack.push("MyStruct");
            assert_eq!(stack.current_fqn(), "my_crate::my_module::MyStruct");
            assert_eq!(stack.depth(), 3);
        }

        #[test]
        fn test_pop_scope() {
            let mut stack = ScopeStack::new(ScopeSeparator::DoubleColon);
            stack.push("my_crate");
            stack.push("my_module");
            assert_eq!(stack.pop(), Some("my_module".to_string()));
            assert_eq!(stack.current_fqn(), "my_crate");
            assert_eq!(stack.pop(), Some("my_crate".to_string()));
            assert!(stack.is_empty());
        }

        #[test]
        fn test_fqn_for_symbol() {
            let mut stack = ScopeStack::new(ScopeSeparator::DoubleColon);
            assert_eq!(stack.fqn_for_symbol("top_level_fn"), "top_level_fn");
            stack.push("my_module");
            assert_eq!(stack.fqn_for_symbol("my_fn"), "my_module::my_fn");
            stack.push("MyStruct");
            assert_eq!(stack.fqn_for_symbol("method"), "my_module::MyStruct::method");
        }

        #[test]
        fn test_fqn_for_anonymous_symbol() {
            let mut stack = ScopeStack::new(ScopeSeparator::DoubleColon);
            stack.push("my_module");
            // Empty symbol name uses parent scope
            assert_eq!(stack.fqn_for_symbol(""), "my_module");
        }

        #[test]
        fn test_dot_separator() {
            let mut stack = ScopeStack::new(ScopeSeparator::Dot);
            stack.push("com");
            stack.push("example");
            stack.push("MyClass");
            assert_eq!(stack.current_fqn(), "com.example.MyClass");
            assert_eq!(stack.fqn_for_symbol("myMethod"), "com.example.MyClass.myMethod");
        }
    }
    ```

    Tests verify core correctness before integrating with parsers.
  </action>
  <verify>cargo test --package magellan ingest::mod::scope_stack_tests passes (all 7 tests pass)</verify>
  <done>ScopeStack has comprehensive test coverage</done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan ingest::mod::scope_stack_tests` - all 7 tests pass
3. Run `cargo test --package magellan` - all existing tests still pass
4. Verify ScopeStack is re-exported from ingest module (check src/ingest/mod.rs pub use)
</verification>

<success_criteria>
1. ScopeStack struct with push/pop operations compiles
2. ScopeSeparator enum provides :: and . separators
3. current_fqn() returns correct FQN for any stack depth
4. fqn_for_symbol() handles empty scopes and anonymous symbols
5. All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-fqn-extraction/11-01-SUMMARY.md`
</output>
