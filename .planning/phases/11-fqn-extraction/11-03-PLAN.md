---
phase: 11-fqn-extraction
plan: 03
type: execute
wave: 3
depends_on: [11-01, 11-02]
files_modified:
  - src/ingest/python.rs
  - src/ingest/java.rs
  - src/ingest/javascript.rs
  - src/ingest/typescript.rs
autonomous: true

must_haves:
  truths:
    - "Python parser tracks class scope (ClassName.method for methods)"
    - "Java parser tracks package and class scope (package.Class.method)"
    - "JavaScript parser tracks class scope for methods"
    - "TypeScript parser tracks namespace and class scope"
    - "All dot-separated languages use ScopeSeparator::Dot"
  artifacts:
    - path: "src/ingest/python.rs"
      contains: "walk_tree_with_scope"
      min_lines: 30
    - path: "src/ingest/java.rs"
      contains: "walk_tree_with_scope"
      min_lines: 30
    - path: "src/ingest/javascript.rs"
      contains: "walk_tree_with_scope"
      min_lines: 30
    - path: "src/ingest/typescript.rs"
      contains: "walk_tree_with_scope"
      min_lines: 30
  key_links:
    - from: "python.rs, java.rs, javascript.rs, typescript.rs"
      to: "src/ingest/mod.rs"
      via: "use crate::ingest::{ScopeStack, ScopeSeparator}"
      pattern: "ScopeStack"
---

<objective>
Update Python, Java, JavaScript, and TypeScript parsers to use ScopeStack for FQN extraction, following the pattern established in the Rust parser.

Purpose: These languages use . (dot) separator and have different scope semantics (packages, namespaces, classes). Each parser needs scope tracking appropriate to its language semantics.

Output:
- Python: class scope tracking (ClassName.method)
- Java: package + class scope (com.example.Class.method)
- JavaScript: class scope for methods
- TypeScript: namespace + class scope
- Tests verifying FQN correctness for each language
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/11-fqn-extraction/11-CONTEXT.md
@.planning/phases/11-fqn-extraction/11-01-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-02-SUMMARY.md
@src/ingest/python.rs
@src/ingest/java.rs
@src/ingest/javascript.rs
@src/ingest/typescript.rs
</context>

<tasks>

<task type="auto">
  <name>Add FQN tracking to Python parser</name>
  <files>src/ingest/python.rs</files>
  <action>
    Update PythonParser to use ScopeStack:

    1. Add import: `use crate::ingest::{ScopeStack, ScopeSeparator};`

    2. Update extract_symbols:
    ```rust
    pub fn extract_symbols(&mut self, file_path: PathBuf, source: &[u8]) -> Vec<SymbolFact> {
        let tree = match self.parser.parse(source, None) {
            Some(t) => t,
            None => return Vec::new(),
        };

        let root_node = tree.root_node();
        let mut facts = Vec::new();
        let mut scope_stack = ScopeStack::new(ScopeSeparator::Dot);

        self.walk_tree_with_scope(&root_node, source, &file_path, &mut facts, &mut scope_stack);

        facts
    }
    ```

    3. Add walk_tree_with_scope:
    ```rust
    fn walk_tree_with_scope(
        &self,
        node: &tree_sitter::Node,
        source: &[u8],
        file_path: &PathBuf,
        facts: &mut Vec<SymbolFact>,
        scope_stack: &mut ScopeStack,
    ) {
        let kind = node.kind();

        // Track class scope
        if kind == "class_definition" {
            if let Some(name) = self.extract_name(node, source) {
                scope_stack.push(&name);
                if let Some(fact) = self.extract_symbol_with_fqn(node, source, file_path, scope_stack) {
                    facts.push(fact);
                }
                let mut cursor = node.walk();
                for child in node.children(&mut cursor) {
                    self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
                }
                scope_stack.pop();
                return;
            }
        }

        if let Some(fact) = self.extract_symbol_with_fqn(node, source, file_path, scope_stack) {
            facts.push(fact);
        }

        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
        }
    }
    ```

    4. Add extract_symbol_with_fqn (similar to Rust version but for Python symbols)
  </action>
  <verify>cargo check --all-targets passes (Python parser compiles)</verify>
  <done>Python parser tracks class scope for FQN building</done>
</task>

<task type="auto">
  <name>Add FQN tracking to Java parser with package scope</name>
  <files>src/ingest/java.rs</files>
  <action>
    Update JavaParser to use ScopeStack with package tracking:

    1. Add import: `use crate::ingest::{ScopeStack, ScopeSeparator};`

    2. Update extract_symbols to find package declaration first:
    ```rust
    pub fn extract_symbols(&mut self, file_path: PathBuf, source: &[u8]) -> Vec<SymbolFact> {
        let tree = match self.parser.parse(source, None) {
            Some(t) => t,
            None => return Vec::new(),
        };

        let root_node = tree.root_node();
        let mut facts = Vec::new();
        let mut scope_stack = ScopeStack::new(ScopeSeparator::Dot);

        // Find package declaration first (it comes first in the file)
        let mut cursor = root_node.walk();
        for child in root_node.children(&mut cursor) {
            if child.kind() == "package_declaration" {
                if let Some(pkg_name) = self.extract_name(child, source, child.kind()) {
                    // Package becomes root scope: com.example.Class
                    for part in pkg_name.split('.') {
                        scope_stack.push(part);
                    }
                }
                break;
            }
        }

        self.walk_tree_with_scope(&root_node, source, &file_path, &mut facts, &mut scope_stack);

        facts
    }
    ```

    3. Add walk_tree_with_scope for class scope tracking

    4. Add extract_symbol_with_fqn for Java symbols

    Java package handling: com.example is split and pushed as separate scopes.
  </action>
  <verify>cargo check --all-targets passes (Java parser compiles)</verify>
  <done>Java parser tracks package and class scope</done>
</task>

<task type="auto">
  <name>Add FQN tracking to JavaScript and TypeScript parsers</name>
  <files>src/ingest/javascript.rs, src/ingest/typescript.rs</files>
  <action>
    Update both parsers similarly:

    For JavaScript (src/ingest/javascript.rs):
    1. Add: `use crate::ingest::{ScopeStack, ScopeSeparator};`
    2. Update extract_symbols to use ScopeStack with Dot separator
    3. Add walk_tree_with_scope tracking class_declaration
    4. Add extract_symbol_with_fqn

    For TypeScript (src/ingest/typescript.rs):
    1. Add: `use crate::ingest::{ScopeStack, ScopeSeparator};`
    2. Update extract_symbols to use ScopeStack with Dot separator
    3. Add walk_tree_with_scope tracking:
       - class_declaration -> push class name
       - internal_module (namespace) -> push namespace name
       - interface_declaration -> push interface name
    4. Add extract_symbol_with_fqn

    TypeScript namespace handling is similar to Rust modules but with . separator.
  </action>
  <verify>cargo check --all-targets passes (both parsers compile)</verify>
  <done>JavaScript and TypeScript parsers track scope for FQN</done>
</task>

<task type="auto">
  <name>Add FQN tests for dot-separated languages</name>
  <files>src/ingest/python.rs, src/ingest/java.rs, src/ingest/javascript.rs, src/ingest/typescript.rs</files>
  <action>
    Add FQN verification tests to each parser:

    Python (test_fqn_class_method):
    ```rust
    #[test]
    fn test_fqn_class_method() {
        let mut parser = PythonParser::new().unwrap();
        let source = b"
class MyClass:
    def my_method(self):
        pass
";
        let facts = parser.extract_symbols(PathBuf::from("test.py"), source);

        let methods: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Function)
            .collect();

        assert_eq!(methods.len(), 1);
        assert_eq!(methods[0].fqn, Some("MyClass.my_method".to_string()));
    }
    ```

    Java (test_fqn_package_class_method):
    ```rust
    #[test]
    fn test_fqn_package_class_method() {
        let mut parser = JavaParser::new().unwrap();
        let source = b"
package com.example;

public class MyClass {
    public void myMethod() {}
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.java"), source);

        let methods: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Method)
            .collect();

        assert_eq!(methods.len(), 1);
        assert_eq!(methods[0].fqn, Some("com.example.MyClass.myMethod".to_string()));
    }
    ```

    Add similar tests for JavaScript and TypeScript.
  </action>
  <verify>
    cargo test --package magellan ingest passes
    FQN tests pass for all four languages
  </verify>
  <done>All dot-separated language parsers have FQN tests</done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan ingest` - all tests pass
3. Verify Python FQNs use . separator (MyClass.method)
4. Verify Java FQNs include package (com.example.Class.method)
5. Verify JavaScript/TypeScript track class and namespace scope
</verification>

<success_criteria>
1. Python parser builds ClassName.method FQNs
2. Java parser builds package.Class.method FQNs
3. JavaScript parser builds ClassName.method FQNs
4. TypeScript parser builds Namespace.Class.method FQNs
5. All use . (dot) separator
6. FQN tests pass for all four languages
</success_criteria>

<output>
After completion, create `.planning/phases/11-fqn-extraction/11-03-SUMMARY.md`
</output>
