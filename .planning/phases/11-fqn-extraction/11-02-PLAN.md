---
phase: 11-fqn-extraction
plan: 02
type: execute
wave: 2
depends_on: [11-01]
files_modified:
  - src/ingest/mod.rs
autonomous: true

must_haves:
  truths:
    - "Rust parser tracks mod, impl, and trait scope during traversal"
    - "FQNs are built as crate::module::Struct::method for nested symbols"
    - "Top-level functions have FQN = function_name"
    - "Methods in impl blocks get parent struct's FQN prefix"
    - "Anonymous impl blocks use parent scope without inventing names"
  artifacts:
    - path: "src/ingest/mod.rs"
      contains: "walk_tree_with_scope"
      exports: ["walk_tree_with_scope", "extract_symbol_with_fqn"]
      min_lines: 100
    - path: "src/ingest/mod.rs"
      contains: "ScopeStack"
      pattern: "ScopeStack"
  key_links:
    - from: "walk_tree_with_scope"
      to: "ScopeStack"
      via: "push/pop calls on scope stack"
      pattern: "scope_stack\\.push|scope_stack\\.pop"
    - from: "extract_symbol_with_fqn"
      to: "SymbolFact"
      via: "fqn field population"
      pattern: "fqn:.*fqn_for_symbol"
---

<objective>
Update the Rust parser (Parser in src/ingest/mod.rs) to use ScopeStack for tracking module and type scope during tree-sitter traversal, building proper fully-qualified names.

Purpose: The Rust parser is the reference implementation for FQN extraction. It demonstrates the pattern for tracking scope (mod items, impl blocks, trait definitions) and building hierarchical FQNs. Other language parsers will follow this pattern.

Output:
- walk_tree_with_scope function that tracks scope during traversal
- extract_symbol_with_fqn that builds FQN from current scope
- Updated Parser struct with scope tracking
- Tests verifying FQN correctness for nested symbols
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/11-fqn-extraction/11-CONTEXT.md
@.planning/phases/11-fqn-extraction/11-01-SUMMARY.md
@src/ingest/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Refactor Parser to use walk_tree_with_scope with ScopeStack</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Modify the Parser implementation:

    1. Update extract_symbols to use scoped traversal:
    ```rust
    pub fn extract_symbols(&mut self, file_path: PathBuf, source: &[u8]) -> Vec<SymbolFact> {
        let tree = match self.parser.parse(source, None) {
            Some(t) => t,
            None => return Vec::new(),
        };

        let root_node = tree.root_node();
        let mut facts = Vec::new();
        let mut scope_stack = ScopeStack::new(ScopeSeparator::DoubleColon);

        // Walk tree with scope tracking
        self.walk_tree_with_scope(&root_node, source, &file_path, &mut facts, &mut scope_stack);

        facts
    }
    ```

    2. Replace walk_tree with walk_tree_with_scope:
    ```rust
    fn walk_tree_with_scope(
        &self,
        node: &tree_sitter::Node,
        source: &[u8],
        file_path: &PathBuf,
        facts: &mut Vec<SymbolFact>,
        scope_stack: &mut ScopeStack,
    ) {
        let kind = node.kind();

        // Track scope boundaries
        match kind {
            "mod_item" => {
                // Extract module name and push to scope
                if let Some(name) = self.extract_name(node, source) {
                    scope_stack.push(&name);
                    if let Some(fact) = self.extract_symbol_with_fqn(node, source, file_path, scope_stack) {
                        facts.push(fact);
                    }
                    // Recurse into children (they're in this module's scope)
                    let mut cursor = node.walk();
                    for child in node.children(&mut cursor) {
                        self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
                    }
                    scope_stack.pop();
                    return;
                }
            }
            "impl_item" => {
                // impl blocks don't add to FQN (syntactic, not semantic)
                // But we need to track them for method scoping
                if let Some(type_name) = self.extract_impl_name(node, source) {
                    scope_stack.push(&type_name);
                    // Don't create a symbol for the impl block itself
                    let mut cursor = node.walk();
                    for child in node.children(&mut cursor) {
                        self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
                    }
                    scope_stack.pop();
                    return;
                }
            }
            "trait_item" => {
                if let Some(name) = self.extract_name(node, source) {
                    scope_stack.push(&name);
                    if let Some(fact) = self.extract_symbol_with_fqn(node, source, file_path, scope_stack) {
                        facts.push(fact);
                    }
                    let mut cursor = node.walk();
                    for child in node.children(&mut cursor) {
                        self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
                    }
                    scope_stack.pop();
                    return;
                }
            }
            _ => {}
        }

        // Check if this node is a symbol we care about
        if let Some(fact) = self.extract_symbol_with_fqn(node, source, file_path, scope_stack) {
            facts.push(fact);
        }

        // Recurse into children
        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
        }
    }
    ```

    Key point: impl blocks push the type name for method scoping but don't create symbols.
  </action>
  <verify>cargo check --all-targets passes (new walk_tree_with_scope compiles)</verify>
  <done>walk_tree_with_scope tracks mod/impl/trait scope</done>
</task>

<task type="auto">
  <name>Implement extract_symbol_with_fqn for building FQNs</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Add the new extraction function that uses current scope:

    ```rust
    fn extract_symbol_with_fqn(
        &self,
        node: &tree_sitter::Node,
        source: &[u8],
        file_path: &PathBuf,
        scope_stack: &ScopeStack,
    ) -> Option<SymbolFact> {
        let kind = node.kind();

        // Skip scope-defining nodes (handled in walk_tree_with_scope)
        if matches!(kind, "mod_item" | "impl_item" | "trait_item") {
            return None;
        }

        let symbol_kind = match kind {
            "function_item" => SymbolKind::Function,
            "struct_item" => SymbolKind::Class,
            "enum_item" => SymbolKind::Enum,
            _ => return None,
        };

        let name = self.extract_name(node, source)?;
        let normalized_kind = symbol_kind.normalized_key().to_string();

        // Build FQN from current scope + symbol name
        let fqn = scope_stack.fqn_for_symbol(&name);

        Some(SymbolFact {
            file_path: file_path.clone(),
            kind: symbol_kind,
            kind_normalized: normalized_kind,
            name: Some(name),
            fqn: Some(fqn),
            byte_start: node.start_byte() as usize,
            byte_end: node.end_byte() as usize,
            start_line: node.start_position().row + 1,
            start_col: node.start_position().column,
            end_line: node.end_position().row + 1,
            end_col: node.end_position().column,
        })
    }
    ```

    Keep the old extract_symbol for backward compatibility during transition.
  </action>
  <verify>cargo check --all-targets passes (extract_symbol_with_fqn compiles)</verify>
  <done>extract_symbol_with_fqn builds proper FQNs from scope stack</done>
</task>

<task type="auto">
  <name>Add FQN tests for Rust parser</name>
  <files>src/ingest/mod.rs</files>
  <action>
    Add tests in the #[cfg(test)] mod tests section:

    ```rust
    #[test]
    fn test_fqn_top_level_function() {
        let mut parser = Parser::new().unwrap();
        let source = b"pub fn top_function() {}\n";
        let facts = parser.extract_symbols(PathBuf::from("test.rs"), source);

        assert_eq!(facts.len(), 1);
        assert_eq!(facts[0].fqn, Some("top_function".to_string()));
    }

    #[test]
    fn test_fqn_module_function() {
        let mut parser = Parser::new().unwrap();
        let source = b"
mod my_module {
    pub fn module_function() {}
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.rs"), source);

        let funcs: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Function)
            .collect();

        assert_eq!(funcs.len(), 1);
        assert_eq!(funcs[0].fqn, Some("my_module::module_function".to_string()));
    }

    #[test]
    fn test_fqn_nested_modules() {
        let mut parser = Parser::new().unwrap();
        let source = b"
mod outer {
    pub fn outer_fn() {}

    mod inner {
        pub fn inner_fn() {}
    }
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.rs"), source);

        let funcs: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Function)
            .collect();

        assert_eq!(funcs.len(), 2);
        assert_eq!(funcs[0].fqn, Some("outer::outer_fn".to_string()));
        assert_eq!(funcs[1].fqn, Some("outer::inner::inner_fn".to_string()));
    }

    #[test]
    fn test_fqn_impl_method() {
        let mut parser = Parser::new().unwrap();
        let source = b"
pub struct MyStruct;

impl MyStruct {
    pub fn my_method(&self) {}
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.rs"), source);

        let methods: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Function)
            .collect();

        assert_eq!(methods.len(), 1);
        assert_eq!(methods[0].fqn, Some("MyStruct::my_method".to_string()));
    }

    #[test]
    fn test_fqn_trait_method() {
        let mut parser = Parser::new().unwrap();
        let source = b"
pub trait MyTrait {
    fn trait_method(&self);
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.rs"), source);

        // Find the trait method (function-like node inside trait)
        let methods: Vec<_> = facts
            .iter()
            .filter(|f| matches!(f.kind, SymbolKind::Function))
            .collect();

        assert!(!methods.is_empty(), "Should find trait method");
        let method = methods.first().unwrap();
        assert_eq!(method.fqn, Some("MyTrait::trait_method".to_string()));
    }
    ```

    These tests verify FQN correctness for all major scope patterns.
  </action>
  <verify>cargo test --package magellan ingest::mod::tests passes (new FQN tests pass)</verify>
  <done>Rust parser FQN tests covering modules, impls, traits</done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan ingest::mod` - all tests pass including new FQN tests
3. Verify top-level functions have FQN = name
4. Verify nested modules build correct FQN path
5. Verify impl methods get parent struct in FQN
</verification>

<success_criteria>
1. Rust parser uses ScopeStack for scope tracking
2. Top-level symbols have simple FQN (just the name)
3. Nested module symbols use :: separator (module::submodule::symbol)
4. Impl methods include parent type (Struct::method)
5. Trait methods include trait name (Trait::method)
6. All FQN tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-fqn-extraction/11-02-SUMMARY.md`
</output>
