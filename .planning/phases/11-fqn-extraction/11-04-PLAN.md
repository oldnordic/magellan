---
phase: 11-fqn-extraction
plan: 04
type: execute
wave: 3
depends_on: [11-01, 11-02]
files_modified:
  - src/ingest/c.rs
  - src/ingest/cpp.rs
autonomous: true

must_haves:
  truths:
    - "C parser has minimal FQN (just symbol name, C has no namespaces)"
    - "C++ parser tracks namespace scope (ns::Class::method)"
    - "C++ nested namespaces build correct FQN path"
    - "Both use :: separator"
  artifacts:
    - path: "src/ingest/c.rs"
      contains: "extract_symbols"
    - path: "src/ingest/cpp.rs"
      contains: "ScopeStack"
      min_lines: 50
    - path: "src/ingest/cpp.rs"
      contains: "walk_tree_with_scope"
  key_links:
    - from: "cpp.rs"
      to: "src/ingest/mod.rs"
      via: "use crate::ingest::{ScopeStack, ScopeSeparator}"
      pattern: "ScopeStack"
---

<objective>
Update C and C++ parsers for FQN extraction. C has no namespaces (FQN = simple name). C++ has namespaces requiring scope tracking.

Purpose: C is trivial (no scope changes needed). C++ needs namespace tracking similar to Rust modules but with its own grammar quirks (nested namespaces, anonymous namespaces).

Output:
- C parser unchanged (FQN = symbol name, already correct)
- C++ parser with namespace scope tracking
- Tests for C++ namespace FQNs
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/11-fqn-extraction/11-CONTEXT.md
@.planning/phases/11-fqn-extraction/11-01-SUMMARY.md
@.planning/phases/11-fqn-extraction/11-02-SUMMARY.md
@src/ingest/c.rs
@src/ingest/cpp.rs
</context>

<tasks>

<task type="auto">
  <name>Update C parser for FQN (no-op, verify fqn field)</name>
  <files>src/ingest/c.rs</files>
  <action>
    C has no namespaces, so FQN = simple name. The parser already sets:
    ```rust
    let fqn = name.clone(); // For v1, FQN is just the symbol name
    ```

    Verify this is still correct (no changes needed). Add a comment:
    ```rust
    // C has no namespaces/packages, FQN is just the symbol name
    let fqn = name.clone();
    ```

    Add a test verifying this behavior:
    ```rust
    #[test]
    fn test_fqn_is_simple_name() {
        let mut parser = CParser::new().unwrap();
        let source = b"int my_function() {}\n";
        let facts = parser.extract_symbols(PathBuf::from("test.c"), source);

        assert_eq!(facts.len(), 1);
        assert_eq!(facts[0].fqn, Some("my_function".to_string()));
    }
    ```

    No scope tracking needed for C.
  </action>
  <verify>cargo test --package magellan c::tests passes</verify>
  <done>C parser verified to use simple name as FQN</done>
</task>

<task type="auto">
  <name>Add namespace tracking to C++ parser</name>
  <files>src/ingest/cpp.rs</files>
  <action>
    Update CppParser to track namespaces:

    1. Add import: `use crate::ingest::{ScopeStack, ScopeSeparator};`

    2. Update extract_symbols:
    ```rust
    pub fn extract_symbols(&mut self, file_path: PathBuf, source: &[u8]) -> Vec<SymbolFact> {
        let tree = match self.parser.parse(source, None) {
            Some(t) => t,
            None => return Vec::new(),
        };

        let root_node = tree.root_node();
        let mut facts = Vec::new();
        let mut scope_stack = ScopeStack::new(ScopeSeparator::DoubleColon);

        self.walk_tree_with_scope(&root_node, source, &file_path, &mut facts, &mut scope_stack);

        facts
    }
    ```

    3. Add walk_tree_with_scope:
    ```rust
    fn walk_tree_with_scope(
        &self,
        node: &tree_sitter::Node,
        source: &[u8],
        file_path: &PathBuf,
        facts: &mut Vec<SymbolFact>,
        scope_stack: &mut ScopeStack,
    ) {
        let kind = node.kind();

        // Skip template_declaration wrapper
        if kind == "template_declaration" {
            let mut cursor = node.walk();
            for child in node.children(&mut cursor) {
                self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
            }
            return;
        }

        // Track namespace scope
        if kind == "namespace_definition" {
            if let Some(name) = self.extract_name(node, source, kind) {
                // Handle anonymous namespaces (empty name)
                if !name.is_empty() {
                    scope_stack.push(&name);
                }
                let mut cursor = node.walk();
                for child in node.children(&mut cursor) {
                    self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
                }
                if !name.is_empty() {
                    scope_stack.pop();
                }
                return;
            }
        }

        if let Some(fact) = self.extract_symbol_with_fqn(node, source, file_path, scope_stack) {
            facts.push(fact);
        }

        let mut cursor = node.walk();
        for child in node.children(&mut cursor) {
            self.walk_tree_with_scope(&child, source, file_path, facts, scope_stack);
        }
    }
    ```

    4. Add extract_symbol_with_fqn (builds FQN from scope_stack)
  </action>
  <verify>cargo check --all-targets passes (C++ parser compiles)</verify>
  <done>C++ parser tracks namespace scope</done>
</task>

<task type="auto">
  <name>Add C++ FQN tests for namespaces</name>
  <files>src/ingest/cpp.rs</files>
  <action>
    Add tests for namespace FQN handling:

    ```rust
    #[test]
    fn test_fqn_simple_namespace() {
        let mut parser = CppParser::new().unwrap();
        let source = b"
namespace MyNamespace {
    void my_function() {}
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.cpp"), source);

        let funcs: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Function)
            .collect();

        assert_eq!(funcs.len(), 1);
        assert_eq!(funcs[0].fqn, Some("MyNamespace::my_function".to_string()));
    }

    #[test]
    fn test_fqn_nested_namespace() {
        let mut parser = CppParser::new().unwrap();
        let source = b"
namespace Outer {
    namespace Inner {
        class MyClass {};
    }
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.cpp"), source);

        let classes: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Class)
            .collect();

        assert_eq!(classes.len(), 1);
        assert_eq!(classes[0].fqn, Some("Outer::Inner::MyClass".to_string()));
    }

    #[test]
    fn test_fqn_class_in_namespace() {
        let mut parser = CppParser::new().unwrap();
        let source = b"
namespace ns {
    struct Point {
        int x;
        int y;
    };
}
";
        let facts = parser.extract_symbols(PathBuf::from("test.cpp"), source);

        let classes: Vec<_> = facts
            .iter()
            .filter(|f| f.kind == SymbolKind::Class)
            .collect();

        assert_eq!(classes.len(), 1);
        assert_eq!(classes[0].fqn, Some("ns::Point".to_string()));
    }
    ```

    These verify C++ namespace handling matches Rust module semantics.
  </action>
  <verify>
    cargo test --package magellan cpp::tests passes
    All new FQN tests pass
  </verify>
  <done>C++ namespace FQN tests added and passing</done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan ingest` - all tests pass
3. Verify C parser FQN = simple name (no scope)
4. Verify C++ parser builds namespace::symbol FQNs
5. Verify nested namespaces: outer::inner::symbol
</verification>

<success_criteria>
1. C parser uses simple name as FQN (no changes needed)
2. C++ parser tracks namespace_definition nodes
3. C++ FQNs use :: separator (ns::Class::method)
4. Nested namespaces build correct path
5. All C++ FQN tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/11-fqn-extraction/11-04-SUMMARY.md`
</output>
