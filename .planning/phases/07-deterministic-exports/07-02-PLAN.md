---
phase: 07-deterministic-exports
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified:
  - src/graph/export.rs
  - src/export_cmd.rs
  - src/main.rs
  - tests/cli_export_tests.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can export call graph to DOT format for Graphviz visualization"
    - "DOT export uses strict digraph for deterministic output"
    - "User can filter DOT export by file, symbol, or max-depth"
    - "User can cluster DOT output by file/module via --cluster flag"
    - "DOT labels are properly escaped for special characters"
    - "DOT output renders correctly with standard Graphviz tools (dot, neato, etc.)"
  artifacts:
    - path: "src/graph/export.rs"
      provides: "DOT export function for call graph visualization"
      exports: ["export_dot", "ExportFilters"]
    - path: "src/export_cmd.rs"
      provides: "DOT export handling with filter support"
      exports: ["run_export with DOT format"]
  key_links:
    - from: "src/export_cmd.rs"
      to: "src/graph/export.rs"
      via: "ExportFormat::Dot dispatch to export_dot()"
    - from: "src/graph/export.rs export_dot"
      to: "CodeGraph.calls backend"
      via: "entity_ids() and get_node() for Call node collection"
    - from: "export_dot"
      to: "string output"
      via: "Hand-rolled DOT format generation with label escaping"
---

<objective>
Export call graph to DOT (Graphviz) format for visualization and filtering.

Purpose: DOT export enables users to visualize call relationships using standard Graphviz tooling. The strict digraph format ensures deterministic output suitable for version control and diffing.

Output: DOT export function with filtering, clustering, and proper label escaping; CLI integration with filter flags.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/07-deterministic-exports/07-CONTEXT.md
@.planning/phases/07-deterministic-exports/07-RESEARCH.md
@.planning/phases/07-deterministic-exports/07-01-SUMMARY.md

# Existing patterns to follow
@src/graph/export.rs
@src/graph/schema.rs
@src/export_cmd.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ExportFilters struct and extend ExportConfig</name>
  <files>src/graph/export.rs</files>
  <action>
    Add ExportFilters struct to src/graph/export.rs for DOT filtering.

    Structure:
    ```rust
    #[derive(Debug, Clone, Default)]
    pub struct ExportFilters {
        pub file: Option<String>,
        pub symbol: Option<String>,
        pub kind: Option<String>,
        pub max_depth: Option<usize>,
        pub cluster: bool,
    }
    ```

    Update ExportConfig from Plan 01:
    - Change filters field from Option<ExportFilters> to filters: ExportFilters
    - Implement Default impl for ExportConfig with sensible defaults

    Filter semantics:
    - file: Only include calls from/to symbols in this file path
    - symbol: Only include calls from/to this specific symbol name
    - kind: Only include symbols of this kind (e.g., "Function", "Method")
    - max_depth: Maximum depth for call graph traversal (None = unlimited)
    - cluster: Group nodes by file in subgraphs (DOT cluster feature)

    These filters apply primarily to DOT export in this plan, but structure is shared for future use.
  </action>
  <verify>cargo check passes; ExportFilters compiles with Default impl</verify>
  <done>ExportFilters struct defined with filter fields for DOT export</done>
</task>

<task type="auto">
  <name>Task 2: Implement DOT label escaping helper function</name>
  <files>src/graph/export.rs</files>
  <action>
    Add escape_dot_label() helper function to src/graph/export.rs.

    According to DOT specification, labels must:
    - Be wrapped in double quotes
    - Escape internal double quotes as \"
    - Escape backslashes as \\
    - Handle other special characters if needed (newlines as \n for labels)

    Implementation:
    ```rust
    fn escape_dot_label(s: &str) -> String {
        format!("\"{}\"",
            s.replace('\\', "\\\\")
                .replace('"', r#"\""#)
                .replace('\n', "\\n")
        )
    }
    ```

    Also add escape_dot_id() for node/edge identifiers (more strict):
    - IDs in DOT should not contain special characters
    - Use SHA-256 based symbol_id as stable identifier
    - Fallback to sanitized name if symbol_id unavailable

    Add unit tests in export.rs test module:
    - Test basic escaping (quotes, backslashes)
    - Test newlines in labels
    - Test empty string
    - Test special characters

    Follow pattern from src/graph/symbols.rs test module.
  </action>
  <verify>cargo test export::tests::test_escape_dot_label passes</verify>
  <done>DOT label escaping function handles special characters correctly</done>
</task>

<task type="auto">
  <name>Task 3: Implement export_dot function</name>
  <files>src/graph/export.rs</files>
  <action>
    Add export_dot() function to src/graph/export.rs.

    Signature:
    ```rust
    pub fn export_dot(graph: &mut CodeGraph, config: &ExportConfig) -> Result<String>
    ```

    Implementation steps:
    1. Collect all Call nodes from graph.calls.backend.entity_ids()
    2. Deserialize to CallNode, filtering by ExportFilters if specified
       - file filter: match call.file
       - symbol filter: match call.caller or call.callee
       - kind filter: require lookup (deferred - use simple file/symbol for now)
    3. Sort calls deterministically: (file, caller, callee) tuple ordering
    4. Build DOT output string:
       - Header: "strict digraph call_graph {" (strict for determinism)
       - Default node attributes: "  node [shape=box, style=rounded];"
       - For clustering: create subgraph cluster_N for each file if config.filters.cluster
       - Emit edges: "  \"caller_label\" -> \"callee_label\";"
       - Footer: "}"

    Node labels format: "{symbol_name}\\n{file_path}" (newline for readability)
    Use symbol_id as internal identifier if available, fallback to sanitized name

    If cluster=true:
    - Create subgraph "cluster_{sanitized_filename}" for each file
    - Place nodes in their file's cluster
    - DOT subgraphs with "cluster_" prefix get visual grouping

    Sorting is critical for determinism - sort calls before emitting edges.
    Use sort_by(|a, b| a.file.cmp(&b.file).then_with(|| a.caller.cmp(&b.caller))...)

    Return complete DOT string.
  </action>
  <verify>
    cargo check passes
    Test export produces valid DOT (can pipe to dot -Tpng if Graphviz available)
    Output starts with "strict digraph call_graph {"
    Output ends with "}"
  </verify>
  <done>export_dot() produces valid DOT with deterministic node/edge ordering</done>
</task>

<task type="auto">
  <name>Task 4: Wire DOT format in export command</name>
  <files>src/export_cmd.rs, src/main.rs</files>
  <action>
    Update src/export_cmd.rs to handle ExportFormat::Dot.

    In run_export(), modify the format dispatch:
    ```rust
    let result = match format {
        ExportFormat::Json => export::export_json_minified(&mut graph, config.minify),
        ExportFormat::JsonL => export::export_jsonl(&mut graph, &config),
        ExportFormat::Dot => export::export_dot(&mut graph, &config),
        ExportFormat::Csv => Err(anyhow::anyhow!("CSV export not yet implemented")),
    }?;
    ```

    Note: export_json_minified may need to be added to handle minify flag.
    If export_json() in CodeGraph doesn't have minify support yet, add export_json_with_config()
    that accepts ExportConfig.

    Update src/main.rs Command::Export arg parsing:
    - Add --dot-cluster flag for enabling clustering
    - Add --dot-file <path> for file filtering
    - Add --dot-symbol <name> for symbol filtering
    - These are format-specific, so prefix with dot- as decided in research

    Or, simpler approach: use generic flags that apply to applicable formats:
    - --cluster (only affects DOT)
    - --file <path> (applies to DOT when filtering by file)
    - --symbol <name> (applies to DOT when filtering by symbol)

    Build ExportFilters from parsed flags and pass to ExportConfig.
  </action>
  <verify>
    cargo check passes
    magellan export --db test.db --format dot produces DOT output
    magellan export --db test.db --format dot --cluster produces clustered DOT
  </verify>
  <done>Export command supports DOT format with filter flags</done>
</task>

<task type="auto">
  <name>Task 5: Add DOT export tests</name>
  <files>tests/cli_export_tests.rs</files>
  <action>
    Add DOT export tests to tests/cli_export_tests.rs.

    Test cases:
    1. test_export_dot_basic - Export to DOT and verify structure
       - Index a simple file with function calls
       - Export to DOT format
       - Verify output starts with "strict digraph"
       - Verify output ends with "}"
       - Verify edges present (-> operator)

    2. test_export_dot_deterministic - Verify deterministic output
       - Export same graph twice to DOT
       - Compare outputs byte-for-byte
       - Should be identical

    3. test_export_dot_label_escaping - Verify special characters handled
       - Index file with symbol containing quotes, backslashes
       - Export to DOT
       - Verify labels are properly escaped

    4. test_export_dot_cluster - Verify clustering works
       - Index multiple files with call relationships
       - Export with --cluster flag
       - Verify "cluster_" subgraphs present in output
       - Verify nodes grouped by file

    5. test_export_dot_filter_file - Verify file filtering
       - Index multiple files
       - Export with --file filter for specific file
       - Verify only calls from that file included

    If Graphviz is available in test environment, add test that renders output:
    6. test_export_dot_renders - Verify DOT can be rendered
       - Export to DOT
       - Pipe to `dot -Tpng` via std::process::Command
       - Verify command succeeds (no parse errors)
       - Skip test if Graphviz not installed

    Follow existing test patterns from cli_query_tests.rs.
  </action>
  <verify>cargo test cli_export_tests::test_export_dot* passes all tests</verify>
  <done>DOT export tests verify correct output structure, determinism, and filtering</done>
</task>

</tasks>

<verification>
- cargo check passes with no warnings
- cargo test cli_export_tests::test_export_dot* passes all 5+ tests
- magellan export --db test.db --format dot produces valid DOT output
- DOT output is deterministic (same input produces identical output)
- magellan export --db test.db --format dot --cluster produces clustered subgraphs
- DOT labels properly escape special characters (quotes, backslashes)
- If Graphviz available: `dot -Tpng output.dot` succeeds without errors
</verification>

<success_criteria>
1. User can export call graph to DOT format for Graphviz visualization
2. DOT export uses strict digraph for deterministic output
3. User can filter DOT export by file or symbol
4. User can cluster DOT output by file via --cluster flag
5. DOT labels are properly escaped for special characters
6. DOT output is deterministic (same input produces identical output)
</success_criteria>

<output>
After completion, create `.planning/phases/07-deterministic-exports/07-02-SUMMARY.md`
</output>
