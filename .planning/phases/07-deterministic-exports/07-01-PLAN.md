---
phase: 07-deterministic-exports
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/export.rs
  - src/graph/mod.rs
  - src/export_cmd.rs
  - src/main.rs
  - Cargo.toml
  - tests/cli_export_tests.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can export graph to JSON with stable symbol_ids and deterministic ordering"
    - "User can export graph to JSONL (one JSON record per line) for streaming"
    - "Exports include symbol_id, caller_symbol_id, callee_symbol_id for stable correlation"
    - "JSON output is deterministic (same input produces identical output)"
    - "User can control minified vs pretty-printed output via --minify flag"
    - "Exported JSON follows schema_version 1.0.0 contract"
  artifacts:
    - path: "src/graph/export.rs"
      provides: "JSON/JSONL export functions with stable IDs"
      exports: ["export_json", "export_jsonl", "ExportFormat", "ExportConfig"]
    - path: "src/export_cmd.rs"
      provides: "Unified export command handler"
      exports: ["run_export"]
    - path: "Cargo.toml"
      contains: "csv = \"1.3\""
  key_links:
    - from: "src/main.rs"
      to: "src/export_cmd.rs"
      via: "Command::Export dispatch to run_export()"
    - from: "src/export_cmd.rs"
      to: "src/graph/export.rs"
      via: "CodeGraph::export_json() / export_jsonl() calls"
    - from: "src/graph/export.rs"
      to: "SymbolNode.symbol_id"
      via: "Include symbol_id in SymbolExport for stable correlation"
---

<objective>
Export graph data to JSON/JSONL formats with stable IDs and deterministic ordering for downstream tooling.

Purpose: JSON/JSONL exports enable external tools to consume Magellan's indexed graph data with stable identifiers that remain consistent across runs. Deterministic ordering ensures reproducible outputs suitable for diffing and version control.

Output: Extended export module with JSONL support, ExportFormat/ExportConfig types, unified CLI export command, and test coverage.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/07-deterministic-exports/07-CONTEXT.md
@.planning/phases/07-deterministic-exports/07-RESEARCH.md
@.planning/phases/05-stable-identity/05-01-SUMMARY.md

# Existing patterns to follow
@src/graph/export.rs
@src/graph/schema.rs
@src/refs_cmd.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CSV dependency and ExportFormat/ExportConfig types</name>
  <files>Cargo.toml, src/graph/export.rs</files>
  <action>
    Add csv = "1.3" to Cargo.toml [dependencies] for Plan 03.

    In src/graph/export.rs, add:
    - ExportFormat enum (Json, JsonL, Dot, Csv) - Dot and Csv are placeholders for plans 02-03
    - ExportConfig struct with fields:
      * format: ExportFormat
      * include_symbols: bool (default true)
      * include_references: bool (default true)
      * include_calls: bool (default true)
      * minify: bool (default false)
      * filters: Option<ExportFilters> (placeholder for future filtering)

    Follow existing serde patterns from src/output/command.rs.
    ExportFormat derives Debug, Clone, Copy, PartialEq, Eq.
    ExportConfig derives Debug, Clone.
  </action>
  <verify>cargo check passes with new types visible in export module</verify>
  <done>ExportFormat and ExportConfig types compile and are accessible from src::graph::export</done>
</task>

<task type="auto">
  <name>Task 2: Add symbol_id and target IDs to export structures</name>
  <files>src/graph/export.rs</files>
  <action>
    Extend existing export structures to include stable IDs:

    1. SymbolExport: Add `pub symbol_id: Option<String>` as first field (after existing fields)
       - Use #[serde(default)] for backward compatibility
       - Document as "Stable symbol ID for cross-run correlation"

    2. ReferenceExport: Add `pub target_symbol_id: Option<String>` field
       - Use #[serde(default)] for backward compatibility
       - Document as "Stable ID of referenced symbol"

    3. CallExport: Add `pub caller_symbol_id: Option<String>` and `pub callee_symbol_id: Option<String>`
       - Use #[serde(default)] for backward compatibility
       - Document as "Stable IDs of caller and callee symbols"

    Follow pattern from src/graph/schema.rs SymbolNode which already has symbol_id field.
    These IDs are populated from SymbolNode/CallNode data during export collection.

    IMPORTANT: Update export_json() to populate these new fields from the entity data:
    - For symbols: Extract from symbol_node.symbol_id
    - For calls: Extract from call_node.caller_symbol_id and call_node.callee_symbol_id
    - For references: Need lookup - defer to Task 3 (may need symbol lookup)
  </action>
  <verify>cargo check passes; export structures compile with new fields</verify>
  <done>Export structures include stable ID fields with proper serde attributes</done>
</task>

<task type="auto">
  <name>Task 3: Implement JSONL export function</name>
  <files>src/graph/export.rs</files>
  <action>
    Add export_jsonl() function following the existing export_json() pattern.

    Key differences from export_json:
    - Returns Result<String> where each line is a compact JSON object (no pretty-printing)
    - Each line includes "type" field to distinguish record types: "File", "Symbol", "Reference", "Call"
    - Uses serde_json::to_string() (not to_string_pretty()) for compact single-line output
    - Records are sorted deterministically before output (same sort keys as export_json)

    Structure:
    - Create JsonlRecord enum with variants File(FileExport), Symbol(SymbolExport), etc.
    - Collect records from graph (reuse existing collection pattern from export_json)
    - Sort deterministically (files by path, symbols by file+name, refs by file+symbol, calls by file+caller+callee)
    - Serialize each record to compact JSON and join with newlines

    Include type discriminator in each JSON line:
    {"type":"File","path":"src/main.rs","hash":"..."}
    {"type":"Symbol","symbol_id":"abc123","name":"main","kind":"Function",...}

    This enables streaming processing where consumers can identify record type per line.
  </action>
  <verify>
    cargo check passes; export_jsonl function compiles
    Test that output is one JSON object per line (no pretty-printing)
  </verify>
  <done>export_jsonl() produces compact line-delimited JSON with type discriminators</done>
</task>

<task type="auto">
  <name>Task 4: Add minify flag support to export_json</name>
  <files>src/graph/export.rs</files>
  <action>
    Modify export_json() function to accept minify parameter.

    Current export_json() always uses serde_json::to_string_pretty().
    Change to:
    - Accept minify: bool parameter
    - Use serde_json::to_string() when minify=true
    - Use serde_json::to_string_pretty() when minify=false (default for backward compatibility)

    For consistency with existing CodeGraph::export_json() method (which has no parameters),
    keep the existing method signature and add new export_json_minified() method.

    Actually, better approach for this phase:
    - Keep existing export_json() unchanged (backward compatibility)
    - Add new export_graph() function that takes ExportConfig parameter
    - export_graph() dispatches to export_json() or export_jsonl() based on config.format

    This preserves existing API while adding new functionality.
  </action>
  <verify>cargo check passes; export_graph function compiles with ExportConfig parameter</verify>
  <done>export_graph() function accepts ExportConfig and dispatches to appropriate format</done>
</task>

<task type="auto">
  <name>Task 5: Create export_cmd.rs module with unified export command</name>
  <files>src/export_cmd.rs, src/main.rs</files>
  <action>
    Create src/export_cmd.rs module following the pattern from src/refs_cmd.rs.

    Implement run_export() function with signature:
    ```rust
    pub fn run_export(
        db_path: PathBuf,
        format: ExportFormat,
        output: Option<PathBuf>,
        include_symbols: bool,
        include_references: bool,
        include_calls: bool,
        minify: bool,
    ) -> Result<()>
    ```

    Implementation:
    1. Open CodeGraph with db_path
    2. Generate execution_id via generate_execution_id()
    3. Start execution logging with command args
    4. Build ExportConfig from parameters
    5. Call export_graph(&mut graph, config) to get output string
    6. Write to stdout if output is None, or to file if output is Some(path)
    7. Finish execution logging with success outcome
    8. Return Ok(()) or error

    In src/main.rs:
    - Add mod export_cmd; declaration
    - Add Command::Export variant with appropriate flags:
      * --format <json|jsonl|dot|csv> (default: json)
      * -o, --output <path> for file output
      * --minify for compact JSON output
      * --no-symbols, --no-references, --no-calls for content filtering (default: include all)
    - Add export command handler following existing pattern:
      ```rust
      Ok(Command::Export { db_path, format, output, .. }) => {
          if let Err(e) = export_cmd::run_export(db_path, format, output, ...) {
              eprintln!("Error: {}", e);
              graph.execution_log().finish_execution(..., "error", ...)?;
              return ExitCode::from(1);
          }
          ExitCode::SUCCESS
      }
      ```

    Follow the arg parsing pattern from Command::Files and Command::Refs in main.rs.
  </action>
  <verify>
    cargo check passes
    magellan export --db test.db --help shows export command usage
    magellan export --db test.db produces JSON output to stdout
    magellan export --db test.db --format jsonl produces JSONL output
    magellan export --db test.db --output export.json writes to file
  </verify>
  <done>Export command works for JSON/JSONL formats with file output and minify support</done>
</task>

<task type="auto">
  <name>Task 6: Add export tests</name>
  <files>tests/cli_export_tests.rs</files>
  <action>
    Create tests/cli_export_tests.rs with comprehensive export tests.

    Test cases:
    1. test_export_json_basic - Export to JSON and verify structure
       - Index a simple file with symbols
       - Run export with format=json
       - Verify output is valid JSON
       - Verify schema_version field (if JsonResponse wrapper used) or just check structure

    2. test_export_json_includes_symbol_ids - Verify stable IDs in export
       - Index file with known symbols
       - Export to JSON
       - Parse output and verify symbol_id field present and non-empty

    3. test_export_jsonl_format - Verify JSONL is one record per line
       - Export to JSONL
       - Split output by lines
       - Verify each line is valid JSON
       - Verify "type" field present in each record

    4. test_export_deterministic - Verify same input produces identical output
       - Export same graph twice
       - Compare byte-for-byte (after sorting if needed)
       - Outputs should be identical

    5. test_export_minify - Verify --minify produces compact JSON
       - Export with minify=true
       - Verify no unnecessary whitespace (to_string not to_string_pretty)

    6. test_export_to_file - Verify file output works
       - Export to temp file
       - Read file and verify content
       - Clean up temp file

    Use tempfile crate for temp file management (already in dev-dependencies).
    Follow pattern from tests/cli_query_tests.rs for test structure.
  </action>
  <verify>cargo test cli_export_tests passes all tests</verify>
  <done>All export tests pass, verifying JSON/JSONL export functionality</done>
</task>

</tasks>

<verification>
- cargo check passes with no warnings
- cargo test cli_export_tests passes all 6+ tests
- magellan export --db test.db produces valid JSON output to stdout
- magellan export --db test.db --format jsonl produces one JSON object per line
- magellan export --db test.db --output export.json writes to file correctly
- magellan export --db test.db --minify produces compact JSON
- JSON exports include symbol_id for symbols, caller_symbol_id/callee_symbol_id for calls
- Exported output is deterministic (same input produces identical output)
- Help text shows all export options clearly
</verification>

<success_criteria>
1. User can export graph to JSON with stable symbol_ids and deterministic ordering
2. User can export graph to JSONL (one JSON record per line) for streaming
3. Exports include symbol_id, caller_symbol_id, callee_symbol_id for stable correlation
4. JSON output is deterministic (same input produces identical output)
5. User can control minified vs pretty-printed output via --minify flag
6. Export command writes to stdout or file via --output flag
</success_criteria>

<output>
After completion, create `.planning/phases/07-deterministic-exports/07-01-SUMMARY.md`
</output>
