---
phase: 02-deterministic-watch--indexing-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - Cargo.toml
  - src/watcher.rs
  - src/indexer.rs
  - src/watch_cmd.rs
  - src/main.rs
  - tests/watch_buffering_tests.rs
autonomous: true

must_haves:
  truths:
    - "Watch mode (by default) starts a watcher immediately, completes scan-initial baseline, then applies any buffered changes that occurred during scan (no missed edits)."
    - "Watcher events are coalesced deterministically into batches processed in sorted path order, not OS arrival order."
  artifacts:
    - path: Cargo.toml
      provides: "notify-debouncer-mini (and/or updated notify) dependency"
    - path: src/watcher.rs
      provides: "Debounced/coalesced watcher that emits dirty-path batches"
    - path: src/indexer.rs
      provides: "Batch processor applying reconcile in sorted order"
    - path: tests/watch_buffering_tests.rs
      provides: "Regression tests for scan buffering + deterministic batch ordering"
  key_links:
    - from: src/watch_cmd.rs
      to: src/indexer.rs
      via: "watch CLI uses new pipeline entrypoint"
      pattern: "run_watch"
    - from: src/watcher.rs
      to: src/indexer.rs
      via: "delivers Vec<PathBuf> / batch events not single events"
      pattern: "batch|Vec"
    - from: src/indexer.rs
      to: src/graph/ops.rs
      via: "batch processing calls reconcile for each path"
      pattern: "reconcile"
---

<objective>
Replace raw per-event processing with a deterministic watch pipeline: start watcher first, buffer/coalesce file events into batches, run scan-initial as a baseline barrier, then flush buffered dirty paths in sorted order using the reconcile operation.

Purpose: Satisfy WATCH-01 (baseline then incremental with no missed edits) and WATCH-02 (deterministic coalescing under storms).
Output: Debounced watcher + batch indexer coordinator + regression tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-RESEARCH.md

# Existing watch pipeline
@src/watcher.rs
@src/indexer.rs
@src/watch_cmd.rs

# Plan 01 output: reconcile operation (required)
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Introduce debounced batch watcher (dirty paths) and update deps</name>
  <files>
    Cargo.toml
    src/watcher.rs
  </files>
  <action>
    - Update dependencies in Cargo.toml to support deterministic debouncing:
      - Add `notify-debouncer-mini`.
      - Upgrade `notify` to a compatible version if required by notify-debouncer-mini (keep changes minimal; follow compilation errors).

    - Refactor src/watcher.rs API from emitting single `FileEvent` to emitting a deterministic batch type:
      - Define a new event type, e.g. `WatcherBatch { paths: Vec<PathBuf> }`.
      - Hard rule: the batch type MUST NOT store timestamps or any other time-derived fields. Time metadata is nondeterministic and MUST NOT influence ordering. Tests MUST NOT assert on timing.
      - Watcher callback should:
        - Treat any incoming notify event as “dirty path(s)” (do not attempt to preserve EventKind semantics).
        - Collect ALL paths from the notify/debouncer event (not just first path).
        - Filter out directories and DB-related files as today.
        - De-duplicate paths within a batch and sort them (lexicographic path order) before sending.

    - Implementation constraint: do NOT hand-roll debounce timing maps. Use notify-debouncer-mini (as per Phase 2 research) or justify why the existing notify version cannot support it.
  </action>
  <verify>
    - cargo test -q
  </verify>
  <done>
    - `WatcherConfig.debounce_ms` is now actually used to control batch boundaries.
    - Watcher delivers sorted, de-duped path batches (not per-event order).
  </done>
</task>

<task type="auto">
  <name>Task 2: Start watcher before scan-initial, buffer batches during scan, flush after</name>
  <files>
    # CLI args live in src/main.rs today (manual parsing).
    # If this changes in the future (clap migration), first DISCOVER the actual args definition file before editing.
    src/main.rs
    src/indexer.rs
    src/watch_cmd.rs
    tests/watch_buffering_tests.rs
  </files>
  <action>
    - Add a new non-test entrypoint in src/indexer.rs that implements the Phase 2 pipeline with *explicit buffering + deterministic drain semantics*:
      - Concurrency model (keep it simple and deterministic):
        - One watcher thread (notify/debouncer callback thread) produces batches.
        - One main/indexer thread performs scan-initial and then processes dirty paths.
      - Buffering model (MUST be bounded in the channel and deterministic in behavior):
        - Maintain a shared `BTreeSet<PathBuf>` (or equivalent deterministic set) of “dirty paths”.
        - Watcher thread inserts paths into the set and then signals the main thread via a *bounded* channel.
          - Recommended: `std::sync::mpsc::sync_channel::<()> (1)` as a wakeup/tick channel.
          - If the channel is full, the watcher thread MUST NOT block; it should drop the tick (the set already contains the information).
        - Deterministic drain rule: when main thread wakes, it drains the set by taking a snapshot, clearing the set, then processing paths in lexicographic order.
      - WATCH-01 default behavior:
        - The watch CLI MUST run scan-initial baseline by default.
        - Add an explicit opt-out flag `--watch-only` that skips baseline scan and goes straight to watch drain loop.

      - CLI args definition update (CURRENTLY src/main.rs; verify via code search if unsure):
        - Add flag: `--watch-only`
          - Default behavior: false (i.e., baseline scan-initial runs by default)
          - Help text: "Watch for changes only; skip initial directory scan baseline"
        - Keep existing flag: `--scan-initial`
          - New default behavior: true (i.e., scan on startup unless --watch-only is set)
          - Help text: "Scan directory for source files on startup (default: true; disabled by --watch-only)"
        - Precedence rule (MUST be encoded explicitly):
          - If `--watch-only` is set, baseline scan is skipped regardless of `--scan-initial` (treat as forced false).
        - Implementation note:
          - This repo currently uses manual argv parsing and a `scan_initial: bool` local variable. Update that parsing + any usage string to reflect the new defaults and the new `--watch-only` flag.
          - If you cannot find the args parsing in src/main.rs, run a targeted code search BEFORE editing to locate where `--scan-initial`/`--debounce-ms` are defined, then update that file instead.

      - If scan-initial enabled (default):
        1) Start watcher + buffering immediately (so edits during scan are captured).
        2) Perform scan_directory baseline indexing.
        3) After scan completes, do a drain cycle: snapshot+clear the dirty set and reconcile each path in sorted order.

      - If `--watch-only` is set:
        - Skip baseline scan_directory.
        - Enter the main loop immediately, still using the same snapshot+clear drain semantics.
      - Then enter main loop:
        - For each wake tick: snapshot+clear the dirty set and reconcile each path in sorted order.
        - For each flushed path, call reconcile (Plan 01) and log outcomes (stdout/stderr handling + per-path error containment is Phase 3; keep current print style for now).

    - Update src/watch_cmd.rs to use this new pipeline coordinator instead of manually scanning + looping on per-event try_recv.

    - Add tests/watch_buffering_tests.rs with at least:
      1) Default behavior: starting `watch` (without passing `--scan-initial`) still performs a scan-initial baseline, indexing files created before watch starts.
      2) Modify a file during scan-initial (spawn a writer thread) and ensure final DB reflects the modified content after flush (no missed edits).
      3) Create multiple rapid modifications; verify final DB state equals “last write” state (storm determinism), without requiring event order assumptions.
      4) Opt-out behavior: starting watch with `--watch-only` does NOT perform baseline scan; ensure only changes observed after watch start are indexed.

    - Keep tests deterministic by using `write_and_sync` helper pattern from tests/indexer_tests.rs.
  </action>
  <verify>
    - cargo test -q watch_buffering_tests -- --nocapture
    - cargo test -q
  </verify>
  <done>
    - Baseline scan happens logically before any buffered incrementals are applied, but no edits during scan are lost.
    - Buffering is bounded (no unbounded channel growth), and drain behavior is deterministic (snapshot+clear, then sorted processing).
    - Under rapid modifications, final indexed state matches the filesystem’s last content.
  </done>
</task>

</tasks>

<verification>
- Run: cargo test -q
- Manual sanity: `cargo run -- watch --root . --db /tmp/magellan.db --debounce-ms 200` then save a file repeatedly; ensure it stays responsive and does not spam unboundedly.
  - Optional: `--watch-only` should skip the baseline scan and start reacting immediately.
</verification>

<success_criteria>
- WATCH-01 satisfied: scan baseline completes and changes during scan are not lost.
- WATCH-02 satisfied: batch processing is deterministic (sorted paths), not arrival-order driven.
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterministic-watch--indexing-pipeline/02-02-SUMMARY.md`
</output>
