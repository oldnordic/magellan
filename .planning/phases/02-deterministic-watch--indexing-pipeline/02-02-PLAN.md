---
phase: 02-deterministic-watch--indexing-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - Cargo.toml
  - src/watcher.rs
  - src/indexer.rs
  - src/watch_cmd.rs
  - tests/watch_buffering_tests.rs
autonomous: true

must_haves:
  truths:
    - "Watch mode starts a watcher immediately, completes scan-initial baseline, then applies any buffered changes that occurred during scan (no missed edits)."
    - "Watcher events are coalesced deterministically into batches processed in sorted path order, not OS arrival order."
  artifacts:
    - path: Cargo.toml
      provides: "notify-debouncer-mini (and/or updated notify) dependency"
    - path: src/watcher.rs
      provides: "Debounced/coalesced watcher that emits dirty-path batches"
    - path: src/indexer.rs
      provides: "Batch processor applying reconcile in sorted order"
    - path: tests/watch_buffering_tests.rs
      provides: "Regression tests for scan buffering + deterministic batch ordering"
  key_links:
    - from: src/watch_cmd.rs
      to: src/indexer.rs
      via: "watch CLI uses new pipeline entrypoint"
      pattern: "run_watch"
    - from: src/watcher.rs
      to: src/indexer.rs
      via: "delivers Vec<PathBuf> / batch events not single events"
      pattern: "batch|Vec"
    - from: src/indexer.rs
      to: src/graph/ops.rs
      via: "batch processing calls reconcile for each path"
      pattern: "reconcile"
---

<objective>
Replace raw per-event processing with a deterministic watch pipeline: start watcher first, buffer/coalesce file events into batches, run scan-initial as a baseline barrier, then flush buffered dirty paths in sorted order using the reconcile operation.

Purpose: Satisfy WATCH-01 (baseline then incremental with no missed edits) and WATCH-02 (deterministic coalescing under storms).
Output: Debounced watcher + batch indexer coordinator + regression tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-RESEARCH.md

# Existing watch pipeline
@src/watcher.rs
@src/indexer.rs
@src/watch_cmd.rs

# Plan 01 output: reconcile operation (required)
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Introduce debounced batch watcher (dirty paths) and update deps</name>
  <files>
    Cargo.toml
    src/watcher.rs
  </files>
  <action>
    - Update dependencies in Cargo.toml to support deterministic debouncing:
      - Add `notify-debouncer-mini`.
      - Upgrade `notify` to a compatible version if required by notify-debouncer-mini (keep changes minimal; follow compilation errors).

    - Refactor src/watcher.rs API from emitting single `FileEvent` to emitting a deterministic batch type:
      - Define a new event type, e.g. `WatcherBatch { paths: Vec<PathBuf>, timestamp: SystemTime }`.
      - Watcher callback should:
        - Treat any incoming notify event as “dirty path(s)” (do not attempt to preserve EventKind semantics).
        - Collect ALL paths from the notify/debouncer event (not just first path).
        - Filter out directories and DB-related files as today.
        - De-duplicate paths within a batch and sort them (lexicographic path order) before sending.

    - Implementation constraint: do NOT hand-roll debounce timing maps. Use notify-debouncer-mini (as per Phase 2 research) or justify why the existing notify version cannot support it.
  </action>
  <verify>
    - cargo test -q
  </verify>
  <done>
    - `WatcherConfig.debounce_ms` is now actually used to control batch boundaries.
    - Watcher delivers sorted, de-duped path batches (not per-event order).
  </done>
</task>

<task type="auto">
  <name>Task 2: Start watcher before scan-initial, buffer batches during scan, flush after</name>
  <files>
    src/indexer.rs
    src/watch_cmd.rs
    tests/watch_buffering_tests.rs
  </files>
  <action>
    - Add a new non-test entrypoint in src/indexer.rs that implements the Phase 2 pipeline:
      - Start watcher immediately.
      - If scan-initial requested:
        1) Perform scan_directory baseline indexing.
        2) While scan runs, keep receiving watcher batches and union them into a `BTreeSet<PathBuf>` (or equivalent deterministic set).
        3) After scan completes, flush the buffered set by processing paths in sorted order and reconciling each.
      - Then enter main loop:
        - Receive watcher batches, union into set, flush set at each batch boundary in sorted order.
        - For each flushed path, call reconcile (Plan 01) and log outcomes (stdout/stderr handling is Phase 3; keep current print style for now).

    - Update src/watch_cmd.rs to use this new pipeline coordinator instead of manually scanning + looping on per-event try_recv.

    - Add tests/watch_buffering_tests.rs with at least:
      1) Create N files before starting watch with scan-initial enabled; verify they are indexed (baseline).
      2) Modify a file during scan-initial (spawn a writer thread) and ensure final DB reflects the modified content after flush (no missed edits).
      3) Create multiple rapid modifications; verify final DB state equals “last write” state (storm determinism), without requiring event order assumptions.

    - Keep tests deterministic by using `write_and_sync` helper pattern from tests/indexer_tests.rs.
  </action>
  <verify>
    - cargo test -q tests::watch_buffering_tests -- --nocapture
    - cargo test -q
  </verify>
  <done>
    - Baseline scan happens logically before any buffered incrementals are applied, but no edits during scan are lost.
    - Under rapid modifications, final indexed state matches the filesystem’s last content.
  </done>
</task>

</tasks>

<verification>
- Run: cargo test -q
- Manual sanity: `cargo run -- watch --root . --db /tmp/magellan.db --scan-initial --debounce-ms 200` then save a file repeatedly; ensure it stays responsive and does not spam unboundedly.
</verification>

<success_criteria>
- WATCH-01 satisfied: scan baseline completes and changes during scan are not lost.
- WATCH-02 satisfied: batch processing is deterministic (sorted paths), not arrival-order driven.
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterministic-watch--indexing-pipeline/02-02-SUMMARY.md`
</output>
