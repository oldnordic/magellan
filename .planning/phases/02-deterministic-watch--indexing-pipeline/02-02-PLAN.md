---
phase: 02-deterministic-watch--indexing-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - Cargo.toml
  - src/watcher.rs
  - src/indexer.rs
  - src/watch_cmd.rs
  - src/main.rs
  - tests/watch_buffering_tests.rs
autonomous: false

must_haves:
  truths:
    - "Watch mode (by default) starts a watcher immediately, completes scan-initial baseline, then applies any buffered changes that occurred during scan (no missed edits)."
    - "Watcher events are coalesced deterministically into batches processed in sorted path order, not OS arrival order."
  artifacts:
    - path: Cargo.toml
      provides: "notify-debouncer-mini dependency after version decision"
    - path: src/watcher.rs
      provides: "Debounced/coalesced watcher that emits dirty-path batches"
    - path: src/indexer.rs
      provides: "Batch processor applying reconcile in sorted order"
    - path: tests/watch_buffering_tests.rs
      provides: "Regression tests for scan buffering + deterministic batch ordering"
  key_links:
    - from: src/watch_cmd.rs
      to: src/indexer.rs
      via: "watch CLI uses new pipeline entrypoint"
      pattern: "run_watch"
    - from: src/watcher.rs
      to: src/indexer.rs
      via: "delivers Vec<PathBuf> / batch events not single events"
      pattern: "batch|Vec"
    - from: src/indexer.rs
      to: src/graph/ops.rs
      via: "batch processing calls reconcile for each path"
      pattern: "reconcile"
---

<objective>
Replace raw per-event processing with a deterministic watch pipeline: start watcher first, buffer/coalesce file events into batches, run scan-initial as a baseline barrier, then flush buffered dirty paths in sorted order using the reconcile operation.

Purpose: Satisfy WATCH-01 (baseline then incremental with no missed edits) and WATCH-02 (deterministic coalescing under storms).
Output: Debounced watcher + batch indexer coordinator + regression tests.

## Design Principles (Phase 2 Foundation)

This plan advances Magellan's design principles for deterministic indexing:

1. **Deterministic ordering**: Batches are flushed in sorted path order, not OS event arrival order. This ensures the same final DB state regardless of editor behavior or event storms.

2. **Structured diagnostics foundation**: Watcher batches enable collection of per-path outcomes (Deleted/Unchanged/Reindexed) that will become structured diagnostics with `execution_id` in Phase 5.

3. **Baseline-first semantics**: Scan-initial completes before any buffered incrementals are applied, ensuring the baseline is always complete. Changes during scan are captured and applied after baseline.

4. **Bounded state**: The dirty-path set is bounded (BTreeSet) with a bounded wakeup channel, preventing unbounded memory growth during massive event storms.

5. **No timing assumptions**: Batch boundaries are controlled only by `debounce_ms`; all sorting and processing is path-based. Tests must not assert on timing.

6. **Span-aware preservation**: Existing byte spans are preserved through reconcile; span model enhancement comes in Phase 4.

7. **JSON preparation**: Diagnostics are collected as structured data (Vec<WatchDiagnostic>) enabling Phase 3's `--output json` contract.

Deferred to later phases:
- Phase 3: Formal JSON output with `schema_version`, stdout/stderr discipline
- Phase 4: Canonical span model with line/col conversion
- Phase 5: `execution_id` generation tying runs to diagnostics
- Phase 8: Pre/post validation hooks (checksums, invariants)


<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-RESEARCH.md

# Existing watch pipeline
@src/watcher.rs
@src/indexer.rs
@src/watch_cmd.rs

# Plan 01 output: reconcile operation (required)
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-01-PLAN.md
</context>

<tasks>

<task type="checkpoint:decision" gate="blocking">
  <name>Decision: notify 7.0 vs 8.x + debouncing strategy</name>
  <decision>
    The research (02-RESEARCH.md) identified a dependency decision:
    - Current: notify = "7.0" in Cargo.toml
    - notify-debouncer-mini (recommended by notify docs) may require notify 8.x

    Decide between:
    A) Upgrade to notify 8.x + use notify-debouncer-mini (recommended for determinism)
    B) Stay on notify 7.x + implement custom debouncing logic (may need to hand-roll)

    Impact: notify 8.x has breaking changes that may require code updates in src/watcher.rs.
  </decision>
  <context>
    Deterministic watch (WATCH-02) requires debounced batching. notify-debouncer-mini is the recommended solution but may require notify 8.x.

    Research finding: "If staying on notify 7.x, notify-debouncer-mini may not be compatible and a custom debounce implementation may be needed."

    The goal is deterministic coalescing (sorted paths), not timing precision. Either option works if implemented correctly.
  </context>
  <options>
    <option id="option-a">
      <name>Option A: Upgrade to notify 8.x + notify-debouncer-mini</name>
      <pros>
        - Uses standard debouncer, avoids hand-rolling debounce logic
        - notify 8.x is latest stable with better cross-platform support
        - Follows notify documentation recommendations
      </pros>
      <cons>
        - May require code changes in src/watcher.rs (breaking API changes)
        - Newer dependency, less field-tested in this codebase
        - May introduce new bugs requiring debugging
      </cons>
    </option>
    <option id="option-b">
      <name>Option B: Stay on notify 7.x + custom debouncing</name>
      <pros>
        - No API changes needed to existing watcher code
        - Keep existing stable dependency
        - Custom debounce is simple: BTreeSet + time window
      </pros>
      <cons>
        - Hand-rolled debounce logic (research discourages this)
        - May miss edge cases in editor behavior that notify-debouncer-mini handles
        - More maintenance burden
      </cons>
    </option>
  </options>
  <resume-signal>Select: option-a or option-b</resume-signal>
</task>

<task type="auto">
  <name>Task 2: Introduce debounced batch watcher (dirty paths) based on version decision</name>
  <files>
    Cargo.toml
    src/watcher.rs
  </files>
  <action>
    DEPENDENCY UPDATE (based on Task 1 decision):

    If Option A (notify 8.x + notify-debouncer-mini) was selected:
    - Update Cargo.toml:
      - Change: notify = "8.2.0" (or latest 8.x)
      - Add: notify-debouncer-mini = "0.7.0"
    - Refactor src/watcher.rs API from emitting single `FileEvent` to emitting a deterministic batch type
    - Use notify-debouncer-mini's new_debouncer API with the existing WatcherConfig.debounce_ms

    If Option B (notify 7.x + custom debounce) was selected:
    - Keep notify = "7.0" in Cargo.toml
    - DO NOT add notify-debouncer-mini
    - Implement custom debouncing in src/watcher.rs:
      - BTreeSet<PathBuf> for dirty path collection
      - std::time::Instant for tracking last flush
      - Check debounce_ms elapsed before emitting batch

    Common requirements for BOTH options:
    - Define a new event type: `WatcherBatch { paths: Vec<PathBuf> }`
    - Hard rule: the batch type MUST NOT store timestamps or any other time-derived fields (nondeterministic)
    - Watcher callback should:
      - Treat any incoming notify event as "dirty path(s)" (do not preserve EventKind semantics)
      - Collect ALL paths from the notify/debouncer event (not just first path)
      - Filter out directories and DB-related files as today
      - De-duplicate paths within a batch and sort them (lexicographic path order) before sending
  </action>
  <verify>
    - cargo test -q
    - cargo check
  </verify>
  <done>
    - `WatcherConfig.debounce_ms` is now actually used to control batch boundaries
    - Watcher delivers sorted, de-duped path batches (not per-event order)
    - Chosen debouncing strategy is implemented and working
  </done>
</task>

<task type="auto">
  <name>Task 3: Start watcher before scan-initial, buffer batches during scan, flush after</name>
  <files>
    src/main.rs
    src/indexer.rs
    src/watch_cmd.rs
    tests/watch_buffering_tests.rs
  </files>
  <action>
    - Add a new non-test entrypoint in src/indexer.rs that implements the Phase 2 pipeline with *explicit buffering + deterministic drain semantics*:
      - Concurrency model (keep it simple and deterministic):
        - One watcher thread (notify/debouncer callback thread) produces batches
        - One main/indexer thread performs scan-initial and then processes dirty paths
      - Buffering model (MUST be bounded in the channel and deterministic in behavior):
        - Maintain a shared `BTreeSet<PathBuf>` (or equivalent deterministic set) of "dirty paths"
        - Watcher thread inserts paths into the set and then signals the main thread via a *bounded* channel
          - Recommended: `std::sync::mpsc::sync_channel::<()> (1)` as a wakeup/tick channel
          - If the channel is full, the watcher thread MUST NOT block; it should drop the tick (the set already contains the information)
        - Deterministic drain rule: when main thread wakes, it drains the set by taking a snapshot, clearing the set, then processing paths in lexicographic order
      - WATCH-01 default behavior:
        - The watch CLI MUST run scan-initial baseline by default
        - Add an explicit opt-out flag `--watch-only` that skips baseline scan and goes straight to watch drain loop

      - CLI args definition update (CURRENTLY src/main.rs; verify via code search if unsure):
        - Add flag: `--watch-only`
          - Default behavior: false (i.e., baseline scan-initial runs by default)
          - Help text: "Watch for changes only; skip initial directory scan baseline"
        - Keep existing flag: `--scan-initial`
          - New default behavior: true (i.e., scan on startup unless --watch-only is set)
          - Help text: "Scan directory for source files on startup (default: true; disabled by --watch-only)"
        - Precedence rule (MUST be encoded explicitly):
          - If `--watch-only` is set, baseline scan is skipped regardless of `--scan-initial` (treat as forced false)
        - Implementation note:
          - This repo currently uses manual argv parsing and a `scan_initial: bool` local variable
          - Update that parsing + any usage string to reflect the new defaults and the new `--watch-only` flag
          - If you cannot find the args parsing in src/main.rs, run a targeted code search BEFORE editing

      - If scan-initial enabled (default):
        1) Start watcher + buffering immediately (so edits during scan are captured)
        2) Perform scan_directory baseline indexing
        3) After scan completes, do a drain cycle: snapshot+clear the dirty set and reconcile each path in sorted order

      - If `--watch-only` is set:
        - Skip baseline scan_directory
        - Enter the main loop immediately, still using the same snapshot+clear drain semantics
      - Then enter main loop:
        - For each wake tick: snapshot+clear the dirty set and reconcile each path in sorted order
        - For each flushed path, call reconcile (Plan 01) and log outcomes (stdout/stderr handling + per-path error containment is Phase 3; keep current print style for now)

    - Update src/watch_cmd.rs to use this new pipeline coordinator instead of manually scanning + looping on per-event try_recv

    - Add tests/watch_buffering_tests.rs with at least:
      1) Default behavior: starting `watch` (without passing `--scan-initial`) still performs a scan-initial baseline, indexing files created before watch starts
      2) Modify a file during scan-initial (spawn a writer thread) and ensure final DB reflects the modified content after flush (no missed edits)
      3) Create multiple rapid modifications; verify final DB state equals "last write" state (storm determinism), without requiring event order assumptions
      4) Opt-out behavior: starting watch with `--watch-only` does NOT perform baseline scan; ensure only changes observed after watch start are indexed

    - Keep tests deterministic by using `write_and_sync` helper pattern from tests/indexer_tests.rs
  </action>
  <verify>
    - cargo test -q watch_buffering_tests -- --nocapture
    - cargo test -q
  </verify>
  <done>
    - Baseline scan happens logically before any buffered incrementals are applied, but no edits during scan are lost
    - Buffering is bounded (no unbounded channel growth), and drain behavior is deterministic (snapshot+clear, then sorted processing)
    - Under rapid modifications, final indexed state matches the filesystem's last content
  </done>
</task>

</tasks>

<verification>
- Run: cargo test -q
- Manual sanity: `cargo run -- watch --root . --db /tmp/magellan.db --debounce-ms 200` then save a file repeatedly; ensure it stays responsive and does not spam unboundedly
  - Optional: `--watch-only` should skip the baseline scan and start reacting immediately
</verification>

<success_criteria>
- WATCH-01 satisfied: scan baseline completes and changes during scan are not lost
- WATCH-02 satisfied: batch processing is deterministic (sorted paths), not arrival-order driven
- Chosen debouncing strategy (notify 8.x or 7.x) is working correctly
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterministic-watch--indexing-pipeline/02-02-SUMMARY.md`
</output>
