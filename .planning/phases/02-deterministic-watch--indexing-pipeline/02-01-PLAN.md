---
phase: 02-deterministic-watch--indexing-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/ops.rs
  - src/graph/files.rs
  - src/graph/references.rs
  - src/graph/call_ops.rs
  - src/graph/schema.rs
  - src/graph/query.rs
  - src/graph/scan.rs
  - src/indexer.rs
  - tests/indexer_determinism_tests.rs
autonomous: true

must_haves:
  truths:
    - "Re-indexing the same file multiple times fully replaces all derived facts (no ghost nodes/edges)."
    - "After reconcile/delete, there are no orphan edges: every edge endpoint refers to an existing entity."
    - "A dirty-path reconcile uses filesystem state + content hash to deterministically decide: delete vs skip vs reindex."
  artifacts:
    - path: src/graph/ops.rs
      provides: "Public reconcile_file_path operation (delete_file_facts already exists)"
    - path: src/graph/references.rs
      provides: "delete_references_in_file (already exists - verified lines 29-63)"
    - path: src/graph/call_ops.rs
      provides: "delete_calls_in_file (already exists - verified lines 29-63)"
    - path: src/graph/schema.rs
      provides: "Edge storage schema + edge deletion/query support"
    - path: src/graph/query.rs
      provides: "Queryable edges/entities for orphan detection in tests"
    - path: tests/indexer_determinism_tests.rs
      provides: "Regression tests proving no ghost refs/calls and no orphan edges across reconcile"
  key_links:
    - from: src/indexer.rs
      to: src/graph/ops.rs
      via: "use CodeGraph reconcile operation instead of delete+index"
      pattern: "reconcile"
    - from: src/graph/ops.rs
      to: src/graph/references.rs
      via: "delete_file_facts deletes reference nodes by file"
      pattern: "delete_.*references"
    - from: src/graph/ops.rs
      to: src/graph/call_ops.rs
      via: "delete_file_facts deletes call nodes by file"
      pattern: "delete_.*calls"
    - from: src/graph/ops.rs
      to: src/graph/schema.rs
      via: "delete_file_facts deletes any edges touching deleted entities"
      pattern: "delete_.*edges"
---

<objective>
Make per-file indexing truly idempotent by introducing a single deterministic "reconcile file" operation that (1) decides action from filesystem state + content hash and (2) deletes ALL file-derived facts (symbols, references, calls, chunks, file node) before re-indexing.

**IMPORTANT: Deletion primitives already implemented.** The research verified that `delete_file_facts`, `delete_references_in_file`, `delete_calls_in_file`, and `ReconcileOutcome` already exist in the codebase. This plan focuses on wiring them together into a public `reconcile_file_path` API and verifying correctness with tests.

Purpose: This is the foundation for deterministic watch under storms (WATCH-02) and true idempotent updates (WATCH-04).
Output: A `CodeGraph` reconcile API + regression tests verifying existing deletion works correctly.

## Design Principles (Phase 2 Foundation)

This plan establishes foundational patterns for Magellan's design principles:

1. **Deterministic ordering**: All file operations are processed in sorted path order; this ensures reproducible DB state regardless of event arrival order.

2. **Structured diagnostics**: Errors and skip reasons are captured as structured data (`WatchDiagnostic` enum) rather than ad-hoc prints; this enables JSON output in Phase 3.

3. **Idempotent persistence**: The reconcile operation ensures repeated indexing of unchanged content produces byte-for-byte identical DB state (no accumulating ghost nodes).

4. **Span-aware preparation**: While full span model is Phase 4, this plan preserves existing `byte_start`/`byte_end` storage and prepares for stable ID derivation.

5. **Execution logging foundation**: The reconcile outcome enum provides structured results that will be tied to `execution_id` in Phase 5 (DB-03).

Deferred to later phases:
- Phase 3: Formal JSON output contract (`--output json` with `schema_version`)
- Phase 4: Canonical span model (line/col mapping, UTF-8 handling)
- Phase 5: Stable `execution_id` generation and correlation
- Phase 8: Validation hooks (pre/post invariants)


<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-RESEARCH.md

# Existing watch/indexing implementation (read before editing)
@src/graph/ops.rs
@src/graph/files.rs
@src/graph/references.rs
@src/graph/call_ops.rs
@src/graph/scan.rs
@indexer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify existing deletion primitives and add hash comparison helper</name>
  <files>
    src/graph/ops.rs
    src/graph/files.rs
  </files>
  <action>
    VERIFICATION UPDATE (2026-01-19): The research confirmed that the following already exist:
    - `delete_file_facts` in src/graph/ops.rs lines 163-242
    - `delete_references_in_file` in src/graph/references.rs lines 29-63
    - `delete_calls_in_file` in src/graph/call_ops.rs lines 29-63
    - `ReconcileOutcome` enum in src/graph/ops.rs lines 11-20

    Task 1 is now focused on:
    1) Adding a helper method to check if a file's hash has changed:
       - In `FileOps` or `CodeGraph`, add `fn file_hash_equals(path: &str, expected_hash: &str) -> Result<bool>`
       - This helper reads the stored FileNode.hash and compares it to a computed hash
       - Returns `Ok(false)` if file doesn't exist (treat as changed, will delete)

    2) Optionally: add a convenience `find_file_node_hash(&self, path: &str) -> Result<Option<String>>` helper

    Do NOT modify existing deletion primitives unless tests reveal bugs.
  </action>
  <verify>
    - cargo test -q
  </verify>
  <done>
    - Hash comparison helper exists and can distinguish unchanged files.
    - Existing deletion primitives remain unchanged (they work).
  </done>
</task>

<task type="auto">
  <name>Task 2: Add reconcile_file_path(path) with exists/hash gating and reuse it in scan/indexer</name>
  <files>
    src/graph/ops.rs
    src/graph/scan.rs
    src/indexer.rs
  </files>
  <action>
    - Add a public deterministic reconcile operation used by BOTH scan-initial and watch updates:
      - Signature: `pub fn reconcile_file_path(graph: &mut CodeGraph, path: &Path) -> Result<ReconcileOutcome>`
      - At reconcile time:
        1) Convert path to stable string (use existing `to_string_lossy()` behavior for now).
        2) If the file does not exist:
           - Call `delete_file_facts(graph, path_str)` (ALREADY EXISTS)
           - Return `ReconcileOutcome::Deleted`
        3) If it exists:
           - Read bytes with `std::fs::read`
           - Compute new hash using existing `graph.files.compute_hash`
           - Use hash comparison helper from Task 1 to check if hash changed
           - If unchanged: return `ReconcileOutcome::Unchanged` without mutating DB
           - If changed or file is new:
             - Call `delete_file_facts(graph, path_str)` (handles symbols + refs + calls + chunks + file node)
             - Call `index_file(graph, path_str, &source)` (handles symbols + chunks + calls)
             - Call `graph.index_references(path_str, &source)` (handles references)
             - Return `ReconcileOutcome::Reindexed { symbols, references, calls }`
      - Ensure failures in parse/indexing are returned as Err here (Phase 2 Plan 03 will convert these into structured diagnostics).

    - Update `scan_directory` and `run_indexer_n` to use the reconcile operation:
      - Keep scan ordering deterministic (already sorts paths)
      - Replace direct `delete_file` + `index_file` + `index_references` calls with `reconcile_file_path`

    - Add/extend `tests/indexer_determinism_tests.rs` with at least:
      1) Test: Index same file twice where content doesn't change; second reconcile returns `Unchanged` and DB unchanged.
      2) Test: Index same file twice where content changes; ensure `count_references()` and `count_calls()` do NOT monotonically increase (verify existing delete works).
      3) Test: Delete the file after indexing; ensure zero Symbols AND References/Calls counts drop to 0.
      4) Test: After each reconcile cycle, query edge storage (direct SQL against temp sqlite DB) and assert ZERO orphan edges:
         - For every edge row (from_id, to_id), both IDs must exist in entities table.
         - Detect schema by inspecting `.schema` in the test.

    Implementation note: `index_file` already handles calls internally, so reconcile only needs:
    - `delete_file_facts` (covers symbols, refs, calls, chunks, file node)
    - `index_file` (covers symbols, chunks, calls)
    - `index_references` (covers references)
  </action>
  <verify>
    - cargo test -q indexer_determinism_tests -- --nocapture
    - cargo test -q
  </verify>
  <done>
    - `reconcile_file_path` is the ONLY code path used by scan and watch updates.
    - All tests pass, proving existing deletion primitives work correctly.
  </done>
</task>

</tasks>

<verification>
- Run: cargo test -q
- Confirm that repeated reconcile cycles for the same file do not accumulate Reference/Call nodes (counts stable).
- Verify orphan edge detection test passes.
</verification>

<success_criteria>
- WATCH-04 foundation: repeated reconcile cycles for the same file do not accumulate Reference/Call nodes (counts stable).
- `reconcile_file_path` public API exists and uses existing `delete_file_facts`.
- Regression tests prove existing deletion primitives prevent ghost/orphan nodes.
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterministic-watch--indexing-pipeline/02-01-SUMMARY.md`
</output>
