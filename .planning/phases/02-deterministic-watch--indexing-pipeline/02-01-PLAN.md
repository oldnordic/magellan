---
phase: 02-deterministic-watch--indexing-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/graph/ops.rs
  - src/graph/files.rs
  - src/graph/references.rs
  - src/graph/call_ops.rs
  - src/graph/schema.rs
  - src/graph/query.rs
  - src/graph/scan.rs
  - src/indexer.rs
  - tests/indexer_determinism_tests.rs
autonomous: true

must_haves:
  truths:
    - "Re-indexing the same file multiple times fully replaces all derived facts (no ghost nodes/edges)."
    - "After reconcile/delete, there are no orphan edges: every edge endpoint refers to an existing entity."
    - "A dirty-path reconcile uses filesystem state + content hash to deterministically decide: delete vs skip vs reindex."
  artifacts:
    - path: src/graph/ops.rs
      provides: "Public reconcile/delete operations (delete_file_facts + reconcile_file_path)"
    - path: src/graph/references.rs
      provides: "Ability to delete reference nodes for a specific file"
    - path: src/graph/call_ops.rs
      provides: "Ability to delete call nodes for a specific file"
    - path: src/graph/schema.rs
      provides: "Edge storage schema + edge deletion/query support"
    - path: src/graph/query.rs
      provides: "Queryable edges/entities for orphan detection in tests"
    - path: tests/indexer_determinism_tests.rs
      provides: "Regression tests proving no ghost refs/calls and no orphan edges across reconcile"
  key_links:
    - from: src/indexer.rs
      to: src/graph/ops.rs
      via: "use CodeGraph reconcile operation instead of delete+index"
      pattern: "reconcile"
    - from: src/graph/ops.rs
      to: src/graph/references.rs
      via: "delete_file_facts deletes reference nodes by file"
      pattern: "delete_.*references"
    - from: src/graph/ops.rs
      to: src/graph/call_ops.rs
      via: "delete_file_facts deletes call nodes by file"
      pattern: "delete_.*calls"
    - from: src/graph/ops.rs
      to: src/graph/schema.rs
      via: "delete_file_facts deletes any edges touching deleted entities"
      pattern: "delete_.*edges"
---

<objective>
Make per-file indexing truly idempotent by introducing a single deterministic “reconcile file” operation that (1) decides action from filesystem state + content hash and (2) deletes ALL file-derived facts (symbols, references, calls, chunks, file node) before re-indexing.

Purpose: This is the foundation for deterministic watch under storms (WATCH-02) and true idempotent updates (WATCH-04).
Output: A `CodeGraph` reconcile API + deletion primitives + regression tests.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-RESEARCH.md

# Existing watch/indexing implementation (read before editing)
@src/graph/ops.rs
@src/graph/files.rs
@src/graph/references.rs
@src/graph/call_ops.rs
@src/graph/scan.rs
@src/indexer.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement delete_file_facts(path) that removes ALL derived nodes</name>
  <files>
    src/graph/ops.rs
    src/graph/references.rs
    src/graph/call_ops.rs
    src/graph/files.rs
    src/graph/schema.rs
    src/graph/query.rs
  </files>
  <action>
    - Add a new graph operation (public on CodeGraph) with semantics:
      - Input: canonical path string used for indexing (current code uses to_string_lossy; do not change path policy in this plan).
      - Behavior:
        1) If a File node exists for this path, delete all Symbols defined by that file (existing delete_file_symbols logic).
        2) Delete ALL Reference nodes whose persisted file_path (or embedded ReferenceNode.file) matches this path.
        3) Delete ALL Call nodes whose persisted file_path (or embedded CallNode.file) matches this path.
        4) Delete all code chunks for this file (existing chunks.delete_chunks_for_file).
        5) Delete the File node itself (if present) and remove from in-memory file index.
      - Determinism requirement: when deleting multiple entities, gather candidate entity IDs, sort ascending, delete in that order.

    - Implement the missing primitives:
      - In src/graph/references.rs: add a method like `delete_references_in_file(&self, path: &str) -> Result<usize>` that scans entities, matches Reference nodes for the file, deletes them, and returns count deleted.
      - In src/graph/call_ops.rs: add a method like `delete_calls_in_file(&self, path: &str) -> Result<usize>` with analogous behavior for Call nodes.

    - Do NOT rely on “edges cascade delete” for correctness here: the goal is to remove orphan nodes AND ensure the edges table contains no rows pointing at deleted entity IDs.
      - Implement explicit edge cleanup for all deleted entity IDs (both from_id and to_id).
      - Put the edge-table delete/query primitives in the graph layer:
        - src/graph/schema.rs: add/extend a method that deletes edges where from_id/to_id is in a provided list of entity IDs.
        - src/graph/query.rs: add/extend a method to enumerate edge endpoints (from_id,to_id) so tests can assert "no orphan edges" without guessing table names.


    - Update existing `delete_file` implementation to delegate to the new `delete_file_facts` so callers get the complete semantics by default.
  </action>
  <verify>
    - cargo test -q
  </verify>
  <done>
    - There is exactly one authoritative file deletion path that deletes symbols + references + calls + chunks for a file.
    - Repeated delete/reindex does not increase `count_references()` / `count_calls()` for stable inputs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add reconcile_file_path(path) with exists/hash gating and reuse it in scan/indexer</name>
  <files>
    src/graph/ops.rs
    src/graph/scan.rs
    src/indexer.rs
  </files>
  <action>
    - Add a deterministic reconcile operation used by BOTH scan-initial and watch updates:
      - Input: `&Path` (or `PathBuf`) plus a stable, explicit string path used as key for DB (keep current path string behavior in this plan).
      - At reconcile time:
        1) If the file does not exist: call delete_file_facts(path_str) and return `Deleted`.
        2) If it exists: read bytes; compute new hash (existing FileOps::compute_hash).
        3) Compare new hash to stored FileNode.hash (use existing FileOps::get_file_node or add a small helper). If unchanged: return `Unchanged` without mutating DB.
        4) If changed/new: call delete_file_facts(path_str), then index symbols+chunks+calls (graph.index_file) and references (graph.index_references), return `Reindexed { symbols, references, calls }`.
      - Ensure failures in parse/indexing are returned as Err here (Phase 2 later will convert these into structured diagnostics instead of crashing).

    - Update scan_directory and run_indexer_n to use the reconcile operation instead of `delete_file` + `index_file` + `index_references`.
      - Keep scan ordering deterministic (already sorts paths).

    - Add/extend `tests/indexer_determinism_tests.rs` with at least:
      1) Index same file twice where content changes: ensure `count_references()` and `count_calls()` do not monotonically increase (no orphans).
      2) Delete the file: ensure there are zero Symbols AND counts for References/Calls drop back to 0 for that file.
      3) After each reconcile cycle, query the edge storage (direct SQL against the temp sqlite DB is fine) and assert there are *zero orphan edges*:
         - For every edge row (from_id, to_id), both IDs must exist in the entities table.
         - If the schema uses different names, detect them by inspecting `.schema` in the test (do not guess).
  </action>
  <verify>
    - cargo test -q indexer_determinism_tests -- --nocapture
    - cargo test -q
  </verify>
  <done>
    - scan and indexer no longer call delete_file + index_* directly; they call reconcile.
    - Added tests fail on old behavior and pass on new behavior.
  </done>
</task>

</tasks>

<verification>
- Run: cargo test -q
- Spot-check that `FileOps::find_or_create_file_node` no longer causes orphan symbols via “delete+insert update” because reconcile deletes file facts before reindex.
</verification>

<success_criteria>
- WATCH-04 foundation: repeated reconcile cycles for the same file do not accumulate Reference/Call nodes (counts stable).
- `delete_file` semantics remove file-derived facts, preventing ghost/orphan nodes.
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterministic-watch--indexing-pipeline/02-01-SUMMARY.md`
</output>
