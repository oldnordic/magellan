---
phase: 02-deterministic-watch--indexing-pipeline
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - Cargo.toml
  - src/graph/scan.rs
  - src/watch_cmd.rs
  - src/indexer.rs
  - tests/ignore_rules_tests.rs
  - src/diagnostics/mod.rs
  - src/diagnostics/watch_diagnostics.rs
autonomous: true

must_haves:
  truths:
    - "User can apply gitignore-style rules + include/exclude globs and Magellan deterministically skips files with explainable reasons."
    - "Per-file failures (unreadable/parse errors) do not stop watch; the failure is recorded as structured diagnostics."
  artifacts:
    - path: Cargo.toml
      provides: "ignore crate dependency (verified NOT present in current Cargo.toml)"
    - path: src/diagnostics/watch_diagnostics.rs
      provides: "Structured WatchDiagnostic (Skip|Error) records"
    - path: src/watch_cmd.rs
      provides: "Collect + surface structured diagnostics while continuing watch"
    - path: tests/ignore_rules_tests.rs
      provides: "Regression tests for include/exclude + skip reasons"
  key_links:
    - from: src/graph/scan.rs
      to: src/diagnostics/watch_diagnostics.rs
      via: "scan emits skip reasons for unsupported/excluded/ignored files"
      pattern: "SkipReason"
    - from: src/indexer.rs
      to: src/diagnostics/watch_diagnostics.rs
      via: "per-path reconcile loop catches errors and records diagnostics while continuing"
      pattern: "WatchDiagnostic::Error"
    - from: src/watch_cmd.rs
      to: src/diagnostics/watch_diagnostics.rs
      via: "watch CLI surfaces diagnostics deterministically"
      pattern: "WatchDiagnostic"
---

<objective>
Add deterministic include/exclude rules and structured per-file diagnostics so users can understand what was skipped and why, and watch keeps running on bad files.

**RESEARCH UPDATE:** The `ignore` crate (for gitignore-style filtering) is NOT present in current Cargo.toml and must be added as a dependency.

Purpose: Satisfy WATCH-03 (ignore/include/exclude + skip reasons) and WATCH-05A (per-file failures captured as structured diagnostics, watch continues; JSON exposure deferred to Phase 3).
Output: Filter policy + diagnostics types + tests.

## Design Principles (Phase 2 Foundation)

This plan completes Phase 2's foundation for Magellan's design principles:

1. **Structured diagnostics**: All skip reasons and errors are captured as `WatchDiagnostic` enum variants with explicit fields (`SkipReason`, `DiagnosticStage`). This enables:
   - Deterministic sorting by path + variant
   - JSON serialization in Phase 3
   - Query from DB in Phase 5

2. **Deterministic filtering**: Gitignore-style matching uses `ignore` crate with deterministic precedence:
   - Internal ignores > gitignore > CLI include > CLI exclude
   - Same file + rules always produces same skip decision

3. **Watch continues on error**: Per-file `Result` wrapping in reconcile loop means bad files don't stop indexing. Errors are collected as diagnostics.

4. **Span preservation**: Byte spans stored in existing entities (symbols, references, calls) are preserved through reconcile. No span model changes in this phase.

5. **JSON-ready structure**: Diagnostics implement `Ord`/sort keys for deterministic output, preparing for Phase 3's `--output json` with `schema_version`.

6. **Stdout discipline (Phase 2 partial)**: Diagnostics print to stderr in Phase 2. Phase 3 enforces full stdout=data-only/stderr=diagnostics discipline.

7. **Execution logging preparation**: Structured outcomes per file enable `execution_id` correlation in Phase 5 (DB-03: execution log table).

Deferred to later phases:
- Phase 3: JSON output with `schema_version`, stable ordering, stdout/stderr discipline
- Phase 4: Canonical span model (byte offsets + line/col, half-open ranges)
- Phase 5: `execution_id`, `match_id`, `span_id`, `symbol_id` stable IDs
- Phase 8: Validation hooks (pre-run checksums, post-run invariants)

## SQLiteGraph Features to Leverage

Per the API guide (docs/SQLITEGRAPH_API_GUIDE.md), sqlitegraph provides:
- `add_label` / `add_property`: Could tag nodes with execution metadata
- Raw SQL access: Can query `graph_labels`/`graph_properties` for diagnostics
- Connection access: Enables direct queries for orphan detection

Phase 2 focuses on core reconcile/watch. Future phases may use labels/properties for execution tracking.


<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-RESEARCH.md

# Existing scan/watch surface
@src/graph/scan.rs
@src/watch_cmd.rs

# Upstream pipeline work
@.planning/phases/02-deterministic-watch--indexing-pipeline/02-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add structured diagnostics types and deterministic ordering</name>
  <files>
    src/diagnostics/mod.rs
    src/diagnostics/watch_diagnostics.rs
  </files>
  <action>
    - Create a small diagnostics module for Phase 2:
      - `WatchDiagnostic` enum with variants:
        - `Skipped { path: String, reason: SkipReason }`
        - `Error { path: String, stage: DiagnosticStage, message: String }`
      - `SkipReason` should cover deterministic reasons we control:
        - UnsupportedLanguage
        - ExcludedByGlob
        - IgnoredByGitignore (matched by ignore crate rules from .gitignore/.ignore)
        - IgnoredInternal (db files, target/, .git/, .codemcp/ etc. â€” reuse existing DB-file filter)
        - NotAFile / DirectoryEvent
      - `DiagnosticStage` should distinguish Read, Parse, IndexSymbols, IndexReferences, IndexCalls

    - Add `impl Ord`/sorting policy (or an explicit `fn sort_key(&self)`) so diagnostics can be output deterministically:
      - Primary: path string
      - Secondary: variant/stage/reason stable key

    - IMPORTANT (WATCH-05 boundary): no JSON output contract work in this phase
      - Phase 2: ensure diagnostic storage + deterministic ordering + deterministic human-readable output (stderr)
      - Phase 3: formalize schema-versioned JSON output and stdout/stderr discipline
  </action>
  <verify>
    - cargo test -q
  </verify>
  <done>
    - Diagnostics are representable as stable, sortable data structures independent of printing
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement gitignore-style + CLI glob filtering, and per-path error containment (watch continues)</name>
  <files>
    Cargo.toml
    src/graph/scan.rs
    src/watch_cmd.rs
    src/indexer.rs
    tests/ignore_rules_tests.rs
  </files>
  <action>
    DEPENDENCY UPDATE (2026-01-19): The `ignore` crate is NOT present in Cargo.toml and must be added:

    - Update Cargo.toml to add:
      - `ignore = "0.4.25"` (gitignore-style matching)
      - Keep existing `globset` for CLI globs (do not hand-roll wildcard matching)

    - Add WATCH-03 filtering support: **gitignore-style ignore rules + CLI include/exclude globs**
      - Sources of ignore rules (deterministic order):
        1) Repository ignores: `.gitignore` (at repo root) and any nested `.gitignore` files under `--root`
        2) User/project ignore file: `.ignore` (same semantics as ripgrep/ignore crate)
        3) **Do not** read global gitignore by default (to keep watch results reproducible across machines)
        4) If you decide to support global gitignore, it MUST be behind an explicit CLI flag (e.g., `--use-global-gitignore`) and covered by tests

      - Deterministic ignore matching requirement:
        - Use `ignore::WalkBuilder` / `ignore::gitignore::GitignoreBuilder` to compile ignore rules once
        - Matching must be performed against a stable, root-relative path representation
        - Do not depend on filesystem traversal order; decisions are per-path and pure

      - CLI patterns (explicit and deterministic):
        - `--include <GLOB>`: only paths matching at least one include are eligible (if no includes provided, treat as "include all")
        - `--exclude <GLOB>`: paths matching any exclude are skipped
        - Globs are evaluated on paths relative to `--root` using `/` separators

      - Precedence rules (MUST be documented in code comments and in `--help` text):
        - Hard internal ignores (db file itself, `.git/`, `.codemcp/`, `target/`, `node_modules/`, hidden dirs if already enforced) always win first
        - Then gitignore-style ignores (from ignore crate) apply
        - Then CLI globs apply with this order:
          1) include gate (if any includes provided)
          2) exclude gate
        - For skip diagnostics, report the first applicable skip reason in that precedence order

    - Apply the SAME filtering function in both scan-initial (src/graph/scan.rs) and watcher processing (src/indexer.rs / watch pipeline):
      - Avoid duplicated logic; create a shared helper (module-local is fine in Phase 2)

    - WATCH-05A: Per-path error containment MUST happen in the *actual processing loop*:
      - In the code path that iterates flushed paths and calls `reconcile_file_path`, wrap each path in its own `match`/`Result` handling
      - On error, push `WatchDiagnostic::Error { path, stage, message }` and continue to the next path (no early-return)
      - Do this in src/indexer.rs (the coordinator / reconcile loop), not only in CLI printing

    - Emit structured diagnostics for skipped files:
      - During scan: accumulate diagnostics (Vec) and return them along with count
      - During watch: collect diagnostics per drain cycle; keep deterministic ordering (sort at output/render time)

    - Deterministic stderr surface (Phase 2):
      - When printing diagnostics in watch_cmd (or whichever layer currently prints), print to stderr only
      - Sort diagnostics using the type's sort_key/Ord before printing
      - Use stable, line-oriented formatting (one diagnostic per line; no timestamps)

    - Add tests/ignore_rules_tests.rs with at least:
      1) `.gitignore` and `.ignore` are honored (e.g., ignore `ignored_dir/**`) and record `Skipped` diagnostics with a reason like `IgnoredByGitignore`
      2) `--include` restricts to a subset even if other files exist
      3) `--exclude` overrides include and prevents indexing; diagnostic reason is `ExcludedByGlob`
      4) Parse/index error on one file does NOT stop indexing other files: DB reflects the good file(s), and diagnostics contain an `Error` for the bad file

    - Keep tests deterministic:
      - Create a temp root with a `.gitignore` and `.ignore` file in the test fixture
      - Write files with `write_and_sync`-style helpers
      - Avoid sleeps if possible; prefer explicit drain/wakeup triggers if the watch pipeline exposes them for tests
  </action>
  <verify>
    - cargo test -q ignore_rules_tests -- --nocapture
    - cargo test -q
  </verify>
  <done>
    - User can configure include/exclude rules and see which files were skipped and why
    - A failing file produces a diagnostic but does not crash/stop watch pipeline
    - The `ignore` crate is now a dependency (verified in Cargo.toml)
  </done>
</task>

</tasks>

<verification>
- cargo test -q
- Run `cargo run -- watch --root . --db /tmp/magellan.db --scan-initial --exclude '**/target/**'` and confirm it doesn't index target/ files and reports skip reasons
- Verify `ignore = "0.4.25"` appears in Cargo.toml
</verification>

<success_criteria>
- WATCH-03 satisfied: include/exclude rules are applied deterministically and surfaced via skip diagnostics
- WATCH-05A satisfied: per-file failures are captured as structured diagnostics and watch continues (JSON output deferred to Phase 3)
- `ignore` crate dependency added to Cargo.toml
</success_criteria>

<output>
After completion, create `.planning/phases/02-deterministic-watch--indexing-pipeline/02-03-SUMMARY.md`
</output>
