---
phase: 09-interop-export
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/graph/export.rs
  - src/export_cmd.rs
  - src/main.rs
  - src/lib.rs
autonomous: true

must_haves:
  truths:
    - "User can export indexed graph to SCIP format via --format scip"
    - "SCIP output file is valid protobuf binary format"
    - "SCIP consumer can parse exported artifact without format errors"
    - "Symbol positions are correctly encoded (0-indexed lines, UTF-8 byte offsets)"
  artifacts:
    - path: "Cargo.toml"
      contains: "scip = \"0.6.1\""
    - path: "src/graph/export.rs"
      contains: "ExportFormat::Scip"
      exports: ["export_scip", "ScipExportConfig"]
    - path: "src/graph/export/scip.rs"
      provides: "SCIP export implementation module"
      min_lines: 50
    - path: "src/export_cmd.rs"
      contains: "ExportFormat::Scip"
    - path: "src/main.rs"
      contains: "\"scip\""
  key_links:
    - from: "src/graph/export.rs"
      to: "scip crate"
      via: "use scip::types as scip"
      pattern: "scip::"
    - from: "src/export_cmd.rs"
      to: "src/graph/export.rs"
      via: "export_scip function call"
      pattern: "export_scip"
    - from: "src/main.rs"
      to: "ExportFormat::Scip"
      via: "ExportFormat::from_str(\"scip\")"
      pattern: "\"scip\""
---

<objective>
Add SCIP (Source Code Intelligence Protocol) export functionality to Magellan, enabling interoperability with standard code intelligence tools.

Purpose: SCIP is the industry standard for code indexing (successor to deprecated LSIF), providing 8x smaller file sizes and 3x faster processing. This phase allows Magellan users to export their indexed graphs to SCIP format for consumption by tools like Sourcegraph, VS Code extensions, and other SCIP-compatible tools.

Output:
- SCIP export module (`src/graph/export/scip.rs`) with functions to convert Magellan's graph to SCIP Index format
- Extended `ExportFormat` enum with `Scip` variant
- CLI integration via `--format scip` flag
- Protobuf binary output file (.scip) valid for SCIP consumers
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-interop-export/09-CONTEXT.md
@.planning/phases/09-interop-export/09-RESEARCH.md
@src/graph/export.rs
@src/graph/schema.rs
@src/export_cmd.rs
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Add scip crate dependency and create SCIP export module</name>
  <files>Cargo.toml, src/graph/export.rs, src/graph/export/scip.rs</files>
  <action>
    1. Add `scip = "0.6.1"` to [dependencies] in Cargo.toml

    2. Create new file src/graph/export/scip.rs with:
    - Module documentation explaining SCIP format mapping
    - `pub struct ScipExportConfig` with project_root field
    - `pub fn export_scip(graph: &mut CodeGraph, config: &ScipExportConfig) -> Result<Vec<u8>>`
    - Helper functions:
      * `to_scip_symbol(symbol_name: &str) -> String` - Format: "magellan . . . escaped_name"
      * `to_scip_range(start_line, start_col, end_line, end_col) -> Vec<i32>` - Convert 1-indexed to 0-indexed
      * `detect_language_from_path(path: &str) -> String` - Map .rs, .py, .js, etc. to SCIP Language enum
      * `to_relative_path(full_path: &str, project_root: &str) -> Result<String>` - Strip root, validate format
    - Use existing CodeGraph methods: files.backend.entity_ids(), get_node(), neighbors()

    3. In src/graph/export.rs:
    - Add `pub mod scip;`
    - Extend ExportFormat enum: `Scip,`
    - Extend ExportFormat::from_str(): `"scip" => Some(ExportFormat::Scip),`
    - Add to export_graph() match arm: `ExportFormat::Scip => export_scip_binary(graph, config),`
    - Add wrapper function: `pub fn export_scip_binary(graph: &mut CodeGraph, config: &ExportConfig) -> Result<String>` - Calls scip::export_scip, returns base64 or file path (since SCIP is binary, not text)

    Reference RESEARCH.md patterns for SCIP Index structure and symbol encoding.
  </action>
  <verify>cargo check --all-targets passes (scip crate resolves, types compile)</verify>
  <done>scip crate added to Cargo.toml, scip.rs module created with export_scip function, ExportFormat::Scip variant added</done>
</task>

<task type="auto">
  <name>Integrate SCIP export into CLI and binary output handling</name>
  <files>src/export_cmd.rs, src/main.rs, src/lib.rs</files>
  <action>
    1. In src/export_cmd.rs:
    - Import SCIP export: `use magellan::graph::export::scip;`
    - Extend format_name() function: `ExportFormat::Scip => "scip".to_string(),`
    - Handle SCIP binary output in run_export():
      * When format == ExportFormat::Scip, write binary bytes directly (not as string)
      * Use file.write_all() for binary data
      * For stdout, still write binary (user should use --output for SCIP)

    2. In src/main.rs:
    - Update usage text: include "scip" in format options
    - Export format parsing already works via ExportFormat::from_str("scip")

    3. In src/lib.rs (if needed for re-export):
    - Re-export any new SCIP types if they should be public API

    SCIP output is binary protobuf, so the write path differs from text formats.
  </action>
  <verify>
    cargo check --all-targets passes
    `magellan export --db test.db --format scip --output test.scip` runs without error
    File test.scip is created and is non-empty (binary data)
  </verify>
  <done>SCIP export integrated into CLI, binary output file written correctly</done>
</task>

<task type="auto">
  <name>Implement SCIP symbol and document conversion with proper encoding</name>
  <files>src/graph/export/scip.rs</files>
  <action>
    Complete the SCIP export implementation in scip.rs:

    1. In export_scip function:
    - Create scip::Index with metadata (tool_info: magellan + version, text_document_encoding: UTF8)
    - Iterate all Symbol nodes via entity_ids()
    - Group symbols by file path
    - For each file, create scip::Document with:
      * relative_path (via to_relative_path)
      * language (via detect_language_from_path)
      * position_encoding: Utf8CodeUnitOffsetFromLineStart
      * occurrences: Vec<scip::Occurrence>
      * symbols: Vec<scip::SymbolInformation>

    2. For each Symbol node, create Occurrence with:
    - range: [start_line-1, start_col, end_line-1, end_col] (convert 1-indexed to 0-indexed)
    - symbol: to_scip_symbol(name)
    - symbol_roles: Definition role (1 << 0)

    3. For each Reference node in the file, create Occurrence with:
    - range: same conversion
    - symbol: to_scip_symbol(referenced_symbol)
    - symbol_roles: 0 (reference only)

    4. Serialize to protobuf: `index.encode(&mut buffer)?`

    5. Deterministic sorting: sort documents by relative_path, occurrences by range

    Use prost::Message for encoding (already included via scip crate).
  </action>
  <verify>
    cargo test --package magellan passes (add basic test for export_scip)
    Output file can be verified with: `scip stats test.scip` if scip CLI available
    Or validate: file starts with protobuf magic bytes
  </verify>
  <done>SCIP export produces valid protobuf with documents, occurrences, and symbol information</done>
</task>

</tasks>

<verification>
1. Run `cargo check --all-targets` - no compilation errors
2. Run `cargo test --package magellan` - all tests pass
3. Create test database, run `magellan export --db test.db --format scip --output test.scip`
4. Verify test.scip is valid protobuf (non-empty binary file)
5. Verify positions encoded correctly (0-indexed lines, UTF-8 offsets)
6. Verify symbol format "magellan . . . symbol_name" used consistently
</verification>

<success_criteria>
1. User can run `magellan export --db <DB> --format scip --output <FILE>` to generate SCIP index
2. Output file is valid SCIP protobuf binary format
3. Symbol positions match Magellan's spans (0-indexed conversion applied)
4. Language detection works for common file extensions (.rs, .py, .js, .ts, .go, etc.)
5. Document relative paths are valid (no leading /, no .. components)
6. Existing export formats (json, jsonl, dot, csv) continue to work unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/09-interop-export/09-01-SUMMARY.md`
</output>
