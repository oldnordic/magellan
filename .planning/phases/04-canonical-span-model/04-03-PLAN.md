---
phase: 04-canonical-span-model
plan: 03
type: execute
wave: 3
depends_on: [04-01, 04-02]
files_modified:
  - src/output/command.rs
  - src/lib.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Span model is documented with module-level docstring"
    - "Half-open range semantics are explicitly documented"
    - "UTF-8 byte offset basis is documented"
    - "Span ID generation algorithm is documented"
    - "Users can understand how to use spans correctly"
  artifacts:
    - path: "src/output/command.rs"
      provides: "Module documentation for span model"
      contains: "//! Span in source code"
    - path: "src/lib.rs"
      provides: "Span export in public API"
  key_links:
    - from: "src/lib.rs"
      to: "src/output/command.rs::Span"
      via: "pub use"
      pattern: "pub use output::command::Span"
---

<objective>
Document the canonical span model in module docs

Purpose: Provide clear documentation for the Span type explaining half-open range semantics, UTF-8 byte offset basis, stable ID generation, and how to use spans correctly. This satisfies the documentation requirement of ID-01 and ensures users understand the span model contract.

Output: Comprehensive module-level documentation in src/output/command.rs with examples, and public Span export in src/lib.rs.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/04-canonical-span-model/04-RESEARCH.md
@src/output/command.rs
@src/lib.rs

# Research documentation requirements from 04-RESEARCH.md:
- Half-open [start, end) semantics with examples
- UTF-8 byte offset basis
- Line/column mapping (1-indexed lines, 0-indexed byte columns)
- SHA-256 based span ID generation
- Comparison with LSP/SCIP/tree-sitter conventions
</context>

<tasks>

<task type="auto">
  <name>Add comprehensive Span module documentation</name>
  <files>src/output/command.rs</files>
  <action>
Update the module-level docstring at the top of src/output/command.rs (currently lines 1-4) to include:

1. **Span Model Overview**: What a Span represents and its contract
2. **Range Semantics**: Half-open [start, end) with concrete example
3. **UTF-8 Byte Offsets**: Explanation that byte offsets are UTF-8 safe, column is byte-based
4. **Line/Column Convention**: 1-indexed lines, 0-indexed byte-based columns
5. **Span ID Generation**: SHA-256 based, position-only (not content-based), 16-char hex
6. **Usage Examples**: How to extract text, validate spans, compare spans
7. **Stability Guarantees**: When IDs change vs stay same
8. **Comparison with Standards**: Brief note on LSP/SCIP alignment

Example format:
```rust
//! # Span Model
//!
//! ## Range Semantics
//! Spans use half-open ranges `[start, end)` where:
//! - `start` is inclusive (first byte INCLUDED)
//! - `end` is exclusive (first byte NOT included)
//!
//! Example: In `"fn main() {}"`, span `[3, 7)` extracts `"main"`
//!
//! ## UTF-8 Safety
//! ...
```

Keep the docstring concise (under 150 lines) but comprehensive. Reference the RESEARCH.md conclusions for rationale.

DO NOT change:
- Any code implementation
- Test code
- Struct definitions (only docstrings on structs)
  </action>
  <verify>
cargo doc --open --no-deps
  </verify>
  <done>
cargo doc renders successfully with no warnings. Span module is well-documented.
  </done>
</task>

<task type="auto">
  <name>Update Span struct docstring with examples</name>
  <files>src/output/command.rs</files>
  <action>
Update the Span struct docstring (lines 46-65) to add:

1. **Usage example**: Creating a span and extracting text
2. **Validation example**: Using .get() for safe UTF-8 slicing
3. **ID example**: How span_id is computed
4. **Serialization note**: Span is serializable for JSON output

Example:
```rust
/// # Examples
///
/// Creating a span and extracting text:
/// ```
/// use magellan::output::command::Span;
/// let source = "fn main() {}";
/// let span = Span::new(...);
/// let text = &source[span.byte_start..span.byte_end]; // "main"
/// ```
///
/// # Safety
///
/// Always use `.get()` for UTF-8 safe slicing:
/// ```
/// let text = source.get(span.byte_start..span.byte_end).unwrap();
/// ```
```

Add similar examples to other public types (SymbolMatch, ReferenceMatch) if they lack examples.
  </action>
  <verify>
cargo test --doc output::command
  </verify>
  <done>
Doc tests pass. All examples compile and run correctly.
  </done>
</task>

<task type="auto">
  <name>Export Span type in public API</name>
  <files>src/lib.rs</files>
  <action>
Check src/lib.rs and ensure Span is exported in the public API:

1. Read src/lib.rs to see current exports
2. If Span is not already exported via `pub use output::command::Span;`, add it
3. Ensure the Span type is accessible to users as `magellan::Span`

This allows downstream users to:
- Import and use Span type directly
- Write tools that work with Magellan spans
- Understand the span model from public docs
  </action>
  <verify>
cargo doc --open --no-deps
# Check that Span appears in public API documentation
  </verify>
  <done>
Span is exported and visible in public API docs.
  </done>
</task>

<task type="auto">
  <name>Add Span helper methods documentation</name>
  <files>src/output/command.rs</files>
  <action>
Review all Span methods (generate_id, new) and ensure:

1. **generate_id()**: Docstring explains SHA-256 algorithm and input format
2. **new()**: Docstring explains all parameters and half-open convention

If any method lacks a docstring, add one. If existing docstrings are unclear, improve them.

Add a "Panics" section if the method can panic (currently none should).

Add a "Stability" section noting that span_id format is part of Magellan's stable API contract.
  </action>
  <verify>
cargo doc --open --no-deps
cargo clippy --all-targets --all-features
  </verify>
  <done>
All Span methods have complete docstrings. No documentation warnings.
  </done>
</task>

</tasks>

<verification>
Build and check documentation:
```bash
cargo doc --open --no-deps
```

Run doctests to verify examples compile:
```bash
cargo test --doc output::command
```

Run full test suite:
```bash
cargo test --workspace
```

Check for documentation warnings:
```bash
cargo doc 2>&1 | grep -i warning || echo "No warnings"
```

Verify Span is in public API:
```bash
cargo doc --open --no-deps
# Navigate to magellan crate, verify Span is listed under "Structs"
```
</verification>

<success_criteria>
1. Module docstring explains span model comprehensively
2. Span struct has usage examples in docstring
3. Half-open semantics clearly documented with example
4. UTF-8 safety documented
5. Span ID generation algorithm documented
6. Span exported in public API
7. All doc tests pass
8. No documentation warnings
9. cargo clippy passes without warnings
</success_criteria>

<output>
After completion, create `.planning/phases/04-canonical-span-model/04-03-SUMMARY.md`
</output>
